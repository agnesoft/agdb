/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


/** OneOf type helpers */
type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };
type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;
type OneOf<T extends any[]> = T extends [infer Only] ? Only : T extends [infer A, infer B, ...infer Rest] ? OneOf<[XOR<A, B>, ...Rest]> : never;

export interface paths {
  "/api/v1/admin/db/list": {
    get: operations["list"];
  };
  "/api/v1/admin/db/{owner}/{db}/add": {
    post: operations["add"];
  };
  "/api/v1/admin/db/{owner}/{db}/backup": {
    post: operations["backup"];
  };
  "/api/v1/admin/db/{owner}/{db}/copy": {
    post: operations["copy"];
  };
  "/api/v1/admin/db/{owner}/{db}/delete": {
    delete: operations["delete"];
  };
  "/api/v1/admin/db/{owner}/{db}/exec": {
    post: operations["exec"];
  };
  "/api/v1/admin/db/{owner}/{db}/optimize": {
    post: operations["optimize"];
  };
  "/api/v1/admin/db/{owner}/{db}/remove": {
    delete: operations["remove"];
  };
  "/api/v1/admin/db/{owner}/{db}/rename": {
    post: operations["rename"];
  };
  "/api/v1/admin/db/{owner}/{db}/user/list": {
    get: operations["list"];
  };
  "/api/v1/admin/db/{owner}/{db}/user/{username}/add": {
    put: operations["add"];
  };
  "/api/v1/admin/db/{owner}/{db}/user/{username}/remove": {
    delete: operations["remove"];
  };
  "/api/v1/admin/shutdown": {
    post: operations["shutdown"];
  };
  "/api/v1/admin/user/list": {
    get: operations["list"];
  };
  "/api/v1/admin/user/{username}/add": {
    post: operations["add"];
  };
  "/api/v1/admin/user/{username}/change_password": {
    put: operations["change_password"];
  };
  "/api/v1/admin/user/{username}/remove": {
    post: operations["remove"];
  };
  "/api/v1/db/admin/{owner}/{db}/restore": {
    post: operations["restore"];
  };
  "/api/v1/db/list": {
    get: operations["list"];
  };
  "/api/v1/db/{owner}/{db}/add": {
    post: operations["add"];
  };
  "/api/v1/db/{owner}/{db}/backup": {
    post: operations["backup"];
  };
  "/api/v1/db/{owner}/{db}/copy": {
    post: operations["copy"];
  };
  "/api/v1/db/{owner}/{db}/delete": {
    post: operations["delete"];
  };
  "/api/v1/db/{owner}/{db}/exec": {
    post: operations["exec"];
  };
  "/api/v1/db/{owner}/{db}/optimize": {
    post: operations["optimize"];
  };
  "/api/v1/db/{owner}/{db}/remove": {
    post: operations["remove"];
  };
  "/api/v1/db/{owner}/{db}/rename": {
    post: operations["rename"];
  };
  "/api/v1/db/{owner}/{db}/restore": {
    post: operations["restore"];
  };
  "/api/v1/db/{owner}/{db}/user/list": {
    get: operations["list"];
  };
  "/api/v1/db/{owner}/{db}/user/{username}/add": {
    post: operations["add"];
  };
  "/api/v1/db/{owner}/{db}/user/{username}/remove": {
    post: operations["remove"];
  };
  "/api/v1/status": {
    get: operations["status"];
  };
  "/api/v1/user/{username}/change_password": {
    put: operations["change_password"];
  };
  "/api/v1/user/{username}/login": {
    post: operations["login"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    ChangePassword: {
      new_password: string;
      password: string;
    };
    /**
     * @description Comparison of database values ([`DbValue`]) used
     * by `key()` condition. Supports
     * the usual set of named comparisons: `==, !=, <, <=, >, =>`
     * plus `contains()`. The comparisons are type
     * strict except for the `contains` comparison
     * which allows vectorized version of the base type. Notably
     * however it does not support the `bytes` and integral types
     * where the "contains" makes little sense (i.e. does 3 contain 1?).
     */
    Comparison: {
      Equal: components["schemas"]["DbValue"];
    } | {
      GreaterThan: components["schemas"]["DbValue"];
    } | {
      GreaterThanOrEqual: components["schemas"]["DbValue"];
    } | {
      LessThan: components["schemas"]["DbValue"];
    } | {
      LessThanOrEqual: components["schemas"]["DbValue"];
    } | {
      NotEqual: components["schemas"]["DbValue"];
    } | {
      Contains: components["schemas"]["DbValue"];
    };
    /**
     * @description Comparison of unsigned integers (`u64`) used
     * by `distance()` and `edge_count*()` conditions. Supports
     * the usual set of named comparisons: `==, !=, <, <=, >, =>`.
     */
    CountComparison: {
      /**
       * Format: int64
       * @description property == this
       */
      Equal: number;
    } | {
      /**
       * Format: int64
       * @description property > this
       */
      GreaterThan: number;
    } | {
      /**
       * Format: int64
       * @description property >= this
       */
      GreaterThanOrEqual: number;
    } | {
      /**
       * Format: int64
       * @description property < this
       */
      LessThan: number;
    } | {
      /**
       * Format: int64
       * @description property <= this
       */
      LessThanOrEqual: number;
    } | {
      /**
       * Format: int64
       * @description property != this
       */
      NotEqual: number;
    };
    /**
     * @description Database element used in [`QueryResult`]
     * that represents a node or an edge.
     */
    DbElement: {
      from?: components["schemas"]["DbId"] | null;
      id: components["schemas"]["DbId"];
      to?: components["schemas"]["DbId"] | null;
      /** @description List of key-value pairs associated with the element. */
      values: components["schemas"]["DbKeyValue"][];
    };
    /**
     * Format: double
     * @description Database float is a wrapper around `f64` to provide
     * functionality like comparison. The comparison is
     * using `total_cmp` standard library function. See its
     * [docs](https://doc.rust-lang.org/std/primitive.f64.html#method.total_cmp)
     * to understand how it handles NaNs and other edge cases
     * of floating point numbers.
     */
    DbF64: number;
    /**
     * Format: int64
     * @description Database id is a wrapper around `i64`.
     * The id is an identifier of a database element
     * both nodes and edges. The positive ids represent nodes,
     * negative ids represent edges. The value of `0` is
     * logically invalid (there cannot be element with id 0) and a default.
     */
    DbId: number;
    /** @description Ordering for search queries */
    DbKeyOrder: OneOf<[{
      Asc: components["schemas"]["DbKey"];
    }, {
      Desc: components["schemas"]["DbKey"];
    }]>;
    /**
     * @description Database key-value pair (aka property) attached to
     * database elements. It can be constructed from a
     * tuple of types that are convertible to `DbValue`.
     */
    DbKeyValue: {
      key: components["schemas"]["DbKey"];
      value: components["schemas"]["DbValue"];
    };
    /** @enum {string} */
    DbType: "memory" | "mapped" | "file";
    DbTypeParam: {
      db_type: components["schemas"]["DbType"];
    };
    DbUser: {
      role: components["schemas"]["DbUserRole"];
      user: string;
    };
    /** @enum {string} */
    DbUserRole: "admin" | "write" | "read";
    DbUserRoleParam: {
      db_role: components["schemas"]["DbUserRole"];
    };
    /**
     * @description Database value is a strongly types value.
     *
     * It is an enum of limited number supported types
     * that are universal across all platforms
     * and programming languages.
     *
     * The value is constructible from large number of
     * raw types or associated types (e.g. i32, &str, etc.).
     * Getting the raw value back as string can be done
     * with `to_string()` but otherwise requires a `match`.
     */
    DbValue: {
      /**
       * Format: binary
       * @description Byte array, sometimes referred to as blob
       */
      Bytes: string;
    } | {
      /**
       * Format: int64
       * @description 64-bit wide signed integer
       */
      I64: number;
    } | {
      /**
       * Format: int64
       * @description 64-bit wide unsigned integer
       */
      U64: number;
    } | {
      F64: components["schemas"]["DbF64"];
    } | {
      /** @description UTF-8 string */
      String: string;
    } | {
      /** @description List of 64-bit wide signed integers */
      VecI64: number[];
    } | {
      /** @description List of 64-bit wide unsigned integers */
      VecU64: number[];
    } | {
      /** @description List of 64-bit floating point numbers */
      VecF64: components["schemas"]["DbF64"][];
    } | {
      /** @description List of UTF-8 strings */
      VecString: string[];
    };
    /**
     * @description Query to insert or update aliases of existing nodes.
     * All `ids` must exist. None of the `aliases` can be empty.
     * If there is an existing alias for any of the elements it
     * will be overwritten with a new one.
     *
     * NOTE: Setting `ids` to a search query will result in an error.
     *
     * The result will contain number of aliases inserted/updated but no elements.
     */
    InsertAliasesQuery: {
      /** @description Aliases to be inserted */
      aliases: string[];
      ids: components["schemas"]["QueryIds"];
    };
    /**
     * @description Query to inserts edges to the database. The `from`
     * and `to` ids must exist in the database. There must be
     * enough `values` for all new edges unless set to `Single`
     * in which case they will be uniformly applied to all new
     * edges. The `each` flag is only useful if `from and `to` are
     * symmetric (same length) but you still want to connect every
     * origin to every destination. By default it would connect only
     * the pairs. For asymmetric inserts `each` is assumed.
     *
     * The result will contain number of edges inserted and elements with
     * their ids but no properties.
     */
    InsertEdgesQuery: {
      /**
       * @description If `true` create an edge between each origin
       * and destination.
       */
      each: boolean;
      from: components["schemas"]["QueryIds"];
      to: components["schemas"]["QueryIds"];
      values: components["schemas"]["QueryValues"];
    };
    /**
     * @description Query to insert nodes to the database. Only one of
     * `count`, `values` or `aliases` need to be given as the
     * implementation will derive the count from the other
     * parameters. If `values` is set to `Single` either `count`
     * or `aliases` must be provided however. If `values` are not
     * set to `Single` there must be enough value for `count/aliases`
     * unless they are not se and the count is derived from `values.
     *
     * The result will contain number of nodes inserted and elements with
     * their ids but no properties.
     */
    InsertNodesQuery: {
      /** @description Aliases of the new nodes. */
      aliases: string[];
      /**
       * Format: int64
       * @description Number of nodes to be inserted.
       */
      count: number;
      values: components["schemas"]["QueryValues"];
    };
    /**
     * @description Query to insert or update key-value pairs (properties)
     * to existing elements in the database. All `ids` must exist
     * in the database. If `values` is set to `Single` the properties
     * will be inserted uniformly to all `ids` otherwise there must be
     * enough `values` for all `ids`.
     *
     * The result will be number of inserted/update values and no elements.
     *
     * NOTE: The result is NOT number of affected elements but individual properties.
     */
    InsertValuesQuery: {
      ids: components["schemas"]["QueryIds"];
      values: components["schemas"]["QueryValues"];
    };
    Queries: components["schemas"]["QueryType"][];
    QueriesResults: components["schemas"]["QueryResult"][];
    /**
     * @description Query condition. The condition consists of
     * `data`, logic operator and a modifier.
     */
    QueryCondition: {
      data: components["schemas"]["QueryConditionData"];
      logic: components["schemas"]["QueryConditionLogic"];
      modifier: components["schemas"]["QueryConditionModifier"];
    };
    /** @description Query condition data */
    QueryConditionData: {
      Distance: components["schemas"]["CountComparison"];
    } | "Edge" | {
      EdgeCount: components["schemas"]["CountComparison"];
    } | {
      EdgeCountFrom: components["schemas"]["CountComparison"];
    } | {
      EdgeCountTo: components["schemas"]["CountComparison"];
    } | {
      /** @description Tests if the current id is in the list of ids. */
      Ids: components["schemas"]["QueryId"][];
    } | {
      /**
       * @description Tests if the current element has a property `key`
       * with a value that evaluates true against `comparison`.
       */
      KeyValue: {
        key: components["schemas"]["DbKey"];
        value: components["schemas"]["Comparison"];
      };
    } | {
      /** @description Test if the current element has **all** of the keys listed. */
      Keys: components["schemas"]["DbKey"][];
    } | "Node" | {
      /** @description Nested list of conditions (equivalent to brackets). */
      Where: components["schemas"]["QueryCondition"][];
    };
    /**
     * @description Logical operator for query conditions
     * @enum {string}
     */
    QueryConditionLogic: "And" | "Or";
    /**
     * @description Query condition modifier
     * @enum {string}
     */
    QueryConditionModifier: "None" | "Beyond" | "Not" | "NotBeyond";
    /**
     * @description Database id used in queries that lets
     * you refer to a database element as numerical
     * id or a string alias.
     */
    QueryId: OneOf<[{
      Id: components["schemas"]["DbId"];
    }, {
      /** @description String alias */
      Alias: string;
    }]>;
    /**
     * @description List of database ids used in queries. It
     * can either represent a list of [`QueryId`]s
     * or a search query. Search query allows query
     * nesting and sourcing the ids dynamically for
     * another query most commonly with the
     * select queries.
     */
    QueryIds: OneOf<[{
      /** @description List of [`QueryId`]s */
      Ids: components["schemas"]["QueryId"][];
    }, {
      Search: components["schemas"]["SearchQuery"];
    }]>;
    /**
     * @description Universal database result. Successful
     * execution of a query will always yield
     * this type. The `result` field is a numerical
     * representation of the result while the
     * `elements` are the list of `DbElement`s
     * with database ids and properties (key-value pairs).
     */
    QueryResult: {
      /**
       * @description List of elements yielded by the query
       * possibly with a list of properties.
       */
      elements: components["schemas"]["DbElement"][];
      /**
       * Format: int64
       * @description Query result
       */
      result: number;
    };
    /** @description Convenience enum for serializing/deserializing queries. */
    QueryType: {
      InsertAlias: components["schemas"]["InsertAliasesQuery"];
    } | {
      InsertEdges: components["schemas"]["InsertEdgesQuery"];
    } | {
      InsertNodes: components["schemas"]["InsertNodesQuery"];
    } | {
      InsertValues: components["schemas"]["InsertValuesQuery"];
    } | {
      Remove: components["schemas"]["RemoveQuery"];
    } | {
      RemoveAliases: components["schemas"]["RemoveAliasesQuery"];
    } | {
      RemoveValues: components["schemas"]["RemoveValuesQuery"];
    } | {
      Search: components["schemas"]["SearchQuery"];
    } | {
      Select: components["schemas"]["SelectQuery"];
    } | {
      SelectAliases: components["schemas"]["SelectAliasesQuery"];
    } | {
      SelectAllAliases: components["schemas"]["SelectAllAliasesQuery"];
    } | {
      SelectKeys: components["schemas"]["SelectKeysQuery"];
    } | {
      SelectKeyCount: components["schemas"]["SelectKeyCountQuery"];
    } | {
      SelectValues: components["schemas"]["SelectValuesQuery"];
    };
    /**
     * @description Helper type distinguishing uniform (`Single`) values
     * and multiple (`Multi`) values in database queries.
     */
    QueryValues: OneOf<[{
      /**
       * @description Single list of properties (key-value pairs)
       * to be applied to all elements in a query.
       */
      Single: components["schemas"]["DbKeyValue"][];
    }, {
      /**
       * @description List of lists of properties (key-value pairs)
       * to be applied to all elements in a query. There
       * must be as many lists of properties as ids
       * in a query.
       */
      Multi: components["schemas"]["DbKeyValue"][][];
    }]>;
    /**
     * @description Query to remove aliases from the database. It
     * is not an error if an alias to be removed already
     * does not exist.
     *
     * The result will be a negative number signifying how
     * many aliases have been actually removed.
     */
    RemoveAliasesQuery: string[];
    RemoveQuery: components["schemas"]["QueryIds"];
    RemoveValuesQuery: components["schemas"]["SelectValuesQuery"];
    /** @description Query to search for ids in the database following the graph. */
    SearchQuery: {
      algorithm: components["schemas"]["SearchQueryAlgorithm"];
      /**
       * @description Set of conditions every element must satisfy to be included in the
       * result. Some conditions also influence the search path as well.
       */
      conditions: components["schemas"]["QueryCondition"][];
      destination: components["schemas"]["QueryId"];
      /**
       * Format: int64
       * @description How many elements maximum to return.
       */
      limit: number;
      /**
       * Format: int64
       * @description How many elements that would be returned should be
       * skipped in the result.
       */
      offset: number;
      /**
       * @description Order of the elements in the result. The sorting happens before
       * `offset` and `limit` are applied.
       */
      order_by: components["schemas"]["DbKeyOrder"][];
      origin: components["schemas"]["QueryId"];
    };
    /**
     * @description Search algorithm to be used
     * @enum {string}
     */
    SearchQueryAlgorithm: "BreadthFirst" | "DepthFirst";
    SelectAliasesQuery: components["schemas"]["QueryIds"];
    /**
     * @description Query to select all aliases in the database.
     *
     * The result will be number of returned aliases and list
     * of elements with a single property `String("alias")` holding
     * the value `String`.
     */
    SelectAllAliasesQuery: Record<string, never>;
    SelectKeyCountQuery: components["schemas"]["QueryIds"];
    SelectKeysQuery: components["schemas"]["QueryIds"];
    SelectQuery: components["schemas"]["QueryIds"];
    /**
     * @description Query to select elements with only certain properties of
     * given ids. All ids must exist in the database and all
     * of them must have the requested properties.
     *
     * The result will be number of elements and the
     * list of elements with the requested properties.
     */
    SelectValuesQuery: {
      ids: components["schemas"]["QueryIds"];
      keys: components["schemas"]["DbKey"][];
    };
    ServerDatabase: {
      /** Format: int64 */
      backup: number;
      db_type: components["schemas"]["DbType"];
      name: string;
      role: components["schemas"]["DbUserRole"];
      /** Format: int64 */
      size: number;
    };
    ServerDatabaseRename: {
      new_name: string;
    };
    UserCredentials: {
      password: string;
    };
    UserStatus: {
      name: string;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  list: {
    parameters: {
      path: {
        /** @description db owner user name */
        owner: string;
        /** @description db name */
        db: string;
      };
    };
    responses: {
      /** @description ok */
      200: {
        content: never;
      };
      /** @description unauthorized */
      401: {
        content: never;
      };
      /** @description db not found */
      404: {
        content: never;
      };
    };
  };
  add: {
    parameters: {
      path: {
        /** @description db owner user name */
        owner: string;
        /** @description db name */
        db: string;
        /** @description user name */
        username: string;
        db_role: components["schemas"]["DbUserRole"];
      };
    };
    responses: {
      /** @description user added */
      201: {
        content: never;
      };
      /** @description unauthorized */
      401: {
        content: never;
      };
      /** @description user must be a db admin / cannot change role of db owner */
      403: {
        content: never;
      };
      /** @description user / db not found */
      404: {
        content: never;
      };
    };
  };
  backup: {
    parameters: {
      path: {
        /** @description user name */
        owner: string;
        /** @description db name */
        db: string;
      };
    };
    responses: {
      /** @description backup created */
      201: {
        content: never;
      };
      /** @description unauthorized */
      401: {
        content: never;
      };
      /** @description must be a db admin / memory db cannot have backup */
      403: {
        content: never;
      };
      /** @description user / db not found */
      404: {
        content: never;
      };
    };
  };
  copy: {
    parameters: {
      path: {
        /** @description db owner user name */
        owner: string;
        /** @description db name */
        db: string;
        new_name: string;
      };
    };
    responses: {
      /** @description db copied */
      201: {
        content: never;
      };
      /** @description unauthorized */
      401: {
        content: never;
      };
      /** @description cannot copy db to another user */
      403: {
        content: never;
      };
      /** @description user / db not found */
      404: {
        content: never;
      };
      /** @description target db exists */
      465: {
        content: never;
      };
      /** @description invalid db */
      467: {
        content: never;
      };
    };
  };
  delete: {
    parameters: {
      path: {
        /** @description db owner user name */
        owner: string;
        /** @description db name */
        db: string;
      };
    };
    responses: {
      /** @description db deleted */
      204: {
        content: never;
      };
      /** @description unauthorized */
      401: {
        content: never;
      };
      /** @description user must be a db owner */
      403: {
        content: never;
      };
      /** @description db not found */
      404: {
        content: never;
      };
    };
  };
  exec: {
    parameters: {
      path: {
        /** @description db owner user name */
        owner: string;
        /** @description db name */
        db: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["Queries"];
      };
    };
    responses: {
      /** @description ok */
      200: {
        content: {
          "application/json": components["schemas"]["QueriesResults"];
        };
      };
      /** @description unauthorized */
      401: {
        content: never;
      };
      /** @description must have at least write role */
      403: {
        content: never;
      };
      /** @description db not found */
      404: {
        content: never;
      };
    };
  };
  optimize: {
    parameters: {
      path: {
        /** @description user name */
        owner: string;
        /** @description db name */
        db: string;
      };
    };
    responses: {
      /** @description ok */
      200: {
        content: {
          "application/json": components["schemas"]["ServerDatabase"];
        };
      };
      /** @description unauthorized */
      401: {
        content: never;
      };
      /** @description must have write permissions */
      403: {
        content: never;
      };
    };
  };
  remove: {
    parameters: {
      path: {
        /** @description db owner user name */
        owner: string;
        /** @description db name */
        db: string;
        /** @description user name */
        username: string;
      };
    };
    responses: {
      /** @description user removed */
      204: {
        content: never;
      };
      /** @description unauthorized */
      401: {
        content: never;
      };
      /** @description must be admin / cannot remove db owner */
      403: {
        content: never;
      };
      /** @description user / db not found */
      404: {
        content: never;
      };
    };
  };
  rename: {
    parameters: {
      path: {
        /** @description db owner user name */
        owner: string;
        /** @description db name */
        db: string;
        new_name: string;
      };
    };
    responses: {
      /** @description db renamed */
      201: {
        content: never;
      };
      /** @description unauthorized */
      401: {
        content: never;
      };
      /** @description user must be a db owner */
      403: {
        content: never;
      };
      /** @description user / db not found */
      404: {
        content: never;
      };
      /** @description target db exists */
      465: {
        content: never;
      };
      /** @description invalid db */
      467: {
        content: never;
      };
    };
  };
  shutdown: {
    responses: {
      /** @description server is shutting down */
      202: {
        content: never;
      };
      /** @description unauthorized */
      401: {
        content: never;
      };
    };
  };
  change_password: {
    parameters: {
      path: {
        /** @description username */
        username: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ChangePassword"];
      };
    };
    responses: {
      /** @description password changed */
      201: {
        content: never;
      };
      /** @description invalid credentials */
      401: {
        content: never;
      };
      /** @description user not found */
      404: {
        content: never;
      };
      /** @description password too short (<8) */
      461: {
        content: never;
      };
    };
  };
  restore: {
    parameters: {
      path: {
        /** @description user name */
        owner: string;
        /** @description db name */
        db: string;
      };
    };
    responses: {
      /** @description db restored */
      201: {
        content: never;
      };
      /** @description unauthorized */
      401: {
        content: never;
      };
      /** @description must be a db admin */
      403: {
        content: never;
      };
      /** @description backup not found */
      404: {
        content: never;
      };
    };
  };
  status: {
    responses: {
      /** @description Server is ready */
      200: {
        content: never;
      };
    };
  };
  login: {
    parameters: {
      path: {
        /** @description username */
        username: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UserCredentials"];
      };
    };
    responses: {
      /** @description login successful */
      200: {
        content: {
          "text/plain": string;
        };
      };
      /** @description invalid credentials */
      401: {
        content: never;
      };
      /** @description user not found */
      404: {
        content: never;
      };
    };
  };
}
