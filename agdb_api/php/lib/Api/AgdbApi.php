<?php
/**
 * AgdbApi
 * PHP version 8.1
 *
 * @category Class
 * @package  Agnesoft\AgdbApi
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * agdb_server
 *
 * Agnesoft Graph Database Server
 *
 * The version of the OpenAPI document: 0.11.2
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.14.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Agnesoft\AgdbApi\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use Agnesoft\AgdbApi\ApiException;
use Agnesoft\AgdbApi\Configuration;
use Agnesoft\AgdbApi\FormDataProcessor;
use Agnesoft\AgdbApi\HeaderSelector;
use Agnesoft\AgdbApi\ObjectSerializer;

/**
 * AgdbApi Class Doc Comment
 *
 * @category Class
 * @package  Agnesoft\AgdbApi
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class AgdbApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'adminDbAdd' => [
            'application/json',
        ],
        'adminDbAudit' => [
            'application/json',
        ],
        'adminDbBackup' => [
            'application/json',
        ],
        'adminDbClear' => [
            'application/json',
        ],
        'adminDbConvert' => [
            'application/json',
        ],
        'adminDbCopy' => [
            'application/json',
        ],
        'adminDbDelete' => [
            'application/json',
        ],
        'adminDbExec' => [
            'application/json',
        ],
        'adminDbExecMut' => [
            'application/json',
        ],
        'adminDbList' => [
            'application/json',
        ],
        'adminDbOptimize' => [
            'application/json',
        ],
        'adminDbRemove' => [
            'application/json',
        ],
        'adminDbRename' => [
            'application/json',
        ],
        'adminDbRestore' => [
            'application/json',
        ],
        'adminDbUserAdd' => [
            'application/json',
        ],
        'adminDbUserList' => [
            'application/json',
        ],
        'adminDbUserRemove' => [
            'application/json',
        ],
        'adminShutdown' => [
            'application/json',
        ],
        'adminStatus' => [
            'application/json',
        ],
        'adminUserAdd' => [
            'application/json',
        ],
        'adminUserChangePassword' => [
            'application/json',
        ],
        'adminUserDelete' => [
            'application/json',
        ],
        'adminUserList' => [
            'application/json',
        ],
        'adminUserLogout' => [
            'application/json',
        ],
        'adminUserLogoutAll' => [
            'application/json',
        ],
        'clusterAdminUserLogout' => [
            'application/json',
        ],
        'clusterAdminUserLogoutAll' => [
            'application/json',
        ],
        'clusterStatus' => [
            'application/json',
        ],
        'clusterUserLogin' => [
            'application/json',
        ],
        'clusterUserLogout' => [
            'application/json',
        ],
        'dbAdd' => [
            'application/json',
        ],
        'dbAudit' => [
            'application/json',
        ],
        'dbBackup' => [
            'application/json',
        ],
        'dbClear' => [
            'application/json',
        ],
        'dbConvert' => [
            'application/json',
        ],
        'dbCopy' => [
            'application/json',
        ],
        'dbDelete' => [
            'application/json',
        ],
        'dbExec' => [
            'application/json',
        ],
        'dbExecMut' => [
            'application/json',
        ],
        'dbList' => [
            'application/json',
        ],
        'dbOptimize' => [
            'application/json',
        ],
        'dbRemove' => [
            'application/json',
        ],
        'dbRename' => [
            'application/json',
        ],
        'dbRestore' => [
            'application/json',
        ],
        'dbUserAdd' => [
            'application/json',
        ],
        'dbUserList' => [
            'application/json',
        ],
        'dbUserRemove' => [
            'application/json',
        ],
        'status' => [
            'application/json',
        ],
        'userChangePassword' => [
            'application/json',
        ],
        'userLogin' => [
            'application/json',
        ],
        'userLogout' => [
            'application/json',
        ],
        'userStatus' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation adminDbAdd
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbType $db_type db_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbAdd'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminDbAdd($owner, $db, $db_type, string $contentType = self::contentTypes['adminDbAdd'][0])
    {
        $this->adminDbAddWithHttpInfo($owner, $db, $db_type, $contentType);
    }

    /**
     * Operation adminDbAddWithHttpInfo
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbType $db_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbAdd'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminDbAddWithHttpInfo($owner, $db, $db_type, string $contentType = self::contentTypes['adminDbAdd'][0])
    {
        $request = $this->adminDbAddRequest($owner, $db, $db_type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation adminDbAddAsync
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbType $db_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminDbAddAsync($owner, $db, $db_type, string $contentType = self::contentTypes['adminDbAdd'][0])
    {
        return $this->adminDbAddAsyncWithHttpInfo($owner, $db, $db_type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminDbAddAsyncWithHttpInfo
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbType $db_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminDbAddAsyncWithHttpInfo($owner, $db, $db_type, string $contentType = self::contentTypes['adminDbAdd'][0])
    {
        $returnType = '';
        $request = $this->adminDbAddRequest($owner, $db, $db_type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminDbAdd'
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbType $db_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminDbAddRequest($owner, $db, $db_type, string $contentType = self::contentTypes['adminDbAdd'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling adminDbAdd'
            );
        }

        // verify the required parameter 'db' is set
        if ($db === null || (is_array($db) && count($db) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db when calling adminDbAdd'
            );
        }

        // verify the required parameter 'db_type' is set
        if ($db_type === null || (is_array($db_type) && count($db_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db_type when calling adminDbAdd'
            );
        }


        $resourcePath = '/api/v1/admin/db/{owner}/{db}/add';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $db_type,
            'db_type', // param base name
            'DbType', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($db !== null) {
            $resourcePath = str_replace(
                '{' . 'db' . '}',
                ObjectSerializer::toPathValue($db),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminDbAudit
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbAudit'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Agnesoft\AgdbApi\Model\QueryAudit[]
     */
    public function adminDbAudit($owner, $db, string $contentType = self::contentTypes['adminDbAudit'][0])
    {
        list($response) = $this->adminDbAuditWithHttpInfo($owner, $db, $contentType);
        return $response;
    }

    /**
     * Operation adminDbAuditWithHttpInfo
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbAudit'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Agnesoft\AgdbApi\Model\QueryAudit[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminDbAuditWithHttpInfo($owner, $db, string $contentType = self::contentTypes['adminDbAudit'][0])
    {
        $request = $this->adminDbAuditRequest($owner, $db, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Agnesoft\AgdbApi\Model\QueryAudit[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Agnesoft\AgdbApi\Model\QueryAudit[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agnesoft\AgdbApi\Model\QueryAudit[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation adminDbAuditAsync
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbAudit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminDbAuditAsync($owner, $db, string $contentType = self::contentTypes['adminDbAudit'][0])
    {
        return $this->adminDbAuditAsyncWithHttpInfo($owner, $db, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminDbAuditAsyncWithHttpInfo
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbAudit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminDbAuditAsyncWithHttpInfo($owner, $db, string $contentType = self::contentTypes['adminDbAudit'][0])
    {
        $returnType = '\Agnesoft\AgdbApi\Model\QueryAudit[]';
        $request = $this->adminDbAuditRequest($owner, $db, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminDbAudit'
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbAudit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminDbAuditRequest($owner, $db, string $contentType = self::contentTypes['adminDbAudit'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling adminDbAudit'
            );
        }

        // verify the required parameter 'db' is set
        if ($db === null || (is_array($db) && count($db) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db when calling adminDbAudit'
            );
        }


        $resourcePath = '/api/v1/admin/db/{owner}/{db}/audit';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($db !== null) {
            $resourcePath = str_replace(
                '{' . 'db' . '}',
                ObjectSerializer::toPathValue($db),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminDbBackup
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbBackup'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminDbBackup($owner, $db, string $contentType = self::contentTypes['adminDbBackup'][0])
    {
        $this->adminDbBackupWithHttpInfo($owner, $db, $contentType);
    }

    /**
     * Operation adminDbBackupWithHttpInfo
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbBackup'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminDbBackupWithHttpInfo($owner, $db, string $contentType = self::contentTypes['adminDbBackup'][0])
    {
        $request = $this->adminDbBackupRequest($owner, $db, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation adminDbBackupAsync
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbBackup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminDbBackupAsync($owner, $db, string $contentType = self::contentTypes['adminDbBackup'][0])
    {
        return $this->adminDbBackupAsyncWithHttpInfo($owner, $db, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminDbBackupAsyncWithHttpInfo
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbBackup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminDbBackupAsyncWithHttpInfo($owner, $db, string $contentType = self::contentTypes['adminDbBackup'][0])
    {
        $returnType = '';
        $request = $this->adminDbBackupRequest($owner, $db, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminDbBackup'
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbBackup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminDbBackupRequest($owner, $db, string $contentType = self::contentTypes['adminDbBackup'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling adminDbBackup'
            );
        }

        // verify the required parameter 'db' is set
        if ($db === null || (is_array($db) && count($db) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db when calling adminDbBackup'
            );
        }


        $resourcePath = '/api/v1/admin/db/{owner}/{db}/backup';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($db !== null) {
            $resourcePath = str_replace(
                '{' . 'db' . '}',
                ObjectSerializer::toPathValue($db),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminDbClear
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbResource $resource resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbClear'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Agnesoft\AgdbApi\Model\ServerDatabase
     */
    public function adminDbClear($owner, $db, $resource, string $contentType = self::contentTypes['adminDbClear'][0])
    {
        list($response) = $this->adminDbClearWithHttpInfo($owner, $db, $resource, $contentType);
        return $response;
    }

    /**
     * Operation adminDbClearWithHttpInfo
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbResource $resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbClear'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Agnesoft\AgdbApi\Model\ServerDatabase, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminDbClearWithHttpInfo($owner, $db, $resource, string $contentType = self::contentTypes['adminDbClear'][0])
    {
        $request = $this->adminDbClearRequest($owner, $db, $resource, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\Agnesoft\AgdbApi\Model\ServerDatabase',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Agnesoft\AgdbApi\Model\ServerDatabase',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agnesoft\AgdbApi\Model\ServerDatabase',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation adminDbClearAsync
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbResource $resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbClear'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminDbClearAsync($owner, $db, $resource, string $contentType = self::contentTypes['adminDbClear'][0])
    {
        return $this->adminDbClearAsyncWithHttpInfo($owner, $db, $resource, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminDbClearAsyncWithHttpInfo
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbResource $resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbClear'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminDbClearAsyncWithHttpInfo($owner, $db, $resource, string $contentType = self::contentTypes['adminDbClear'][0])
    {
        $returnType = '\Agnesoft\AgdbApi\Model\ServerDatabase';
        $request = $this->adminDbClearRequest($owner, $db, $resource, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminDbClear'
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbResource $resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbClear'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminDbClearRequest($owner, $db, $resource, string $contentType = self::contentTypes['adminDbClear'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling adminDbClear'
            );
        }

        // verify the required parameter 'db' is set
        if ($db === null || (is_array($db) && count($db) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db when calling adminDbClear'
            );
        }

        // verify the required parameter 'resource' is set
        if ($resource === null || (is_array($resource) && count($resource) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource when calling adminDbClear'
            );
        }


        $resourcePath = '/api/v1/admin/db/{owner}/{db}/clear';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $resource,
            'resource', // param base name
            'DbResource', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($db !== null) {
            $resourcePath = str_replace(
                '{' . 'db' . '}',
                ObjectSerializer::toPathValue($db),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminDbConvert
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbType $db_type db_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbConvert'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminDbConvert($owner, $db, $db_type, string $contentType = self::contentTypes['adminDbConvert'][0])
    {
        $this->adminDbConvertWithHttpInfo($owner, $db, $db_type, $contentType);
    }

    /**
     * Operation adminDbConvertWithHttpInfo
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbType $db_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbConvert'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminDbConvertWithHttpInfo($owner, $db, $db_type, string $contentType = self::contentTypes['adminDbConvert'][0])
    {
        $request = $this->adminDbConvertRequest($owner, $db, $db_type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation adminDbConvertAsync
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbType $db_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbConvert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminDbConvertAsync($owner, $db, $db_type, string $contentType = self::contentTypes['adminDbConvert'][0])
    {
        return $this->adminDbConvertAsyncWithHttpInfo($owner, $db, $db_type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminDbConvertAsyncWithHttpInfo
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbType $db_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbConvert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminDbConvertAsyncWithHttpInfo($owner, $db, $db_type, string $contentType = self::contentTypes['adminDbConvert'][0])
    {
        $returnType = '';
        $request = $this->adminDbConvertRequest($owner, $db, $db_type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminDbConvert'
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbType $db_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbConvert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminDbConvertRequest($owner, $db, $db_type, string $contentType = self::contentTypes['adminDbConvert'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling adminDbConvert'
            );
        }

        // verify the required parameter 'db' is set
        if ($db === null || (is_array($db) && count($db) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db when calling adminDbConvert'
            );
        }

        // verify the required parameter 'db_type' is set
        if ($db_type === null || (is_array($db_type) && count($db_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db_type when calling adminDbConvert'
            );
        }


        $resourcePath = '/api/v1/admin/db/{owner}/{db}/convert';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $db_type,
            'db_type', // param base name
            'DbType', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($db !== null) {
            $resourcePath = str_replace(
                '{' . 'db' . '}',
                ObjectSerializer::toPathValue($db),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminDbCopy
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $new_owner new_owner (required)
     * @param  string $new_db new_db (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbCopy'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminDbCopy($owner, $db, $new_owner, $new_db, string $contentType = self::contentTypes['adminDbCopy'][0])
    {
        $this->adminDbCopyWithHttpInfo($owner, $db, $new_owner, $new_db, $contentType);
    }

    /**
     * Operation adminDbCopyWithHttpInfo
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $new_owner (required)
     * @param  string $new_db (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbCopy'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminDbCopyWithHttpInfo($owner, $db, $new_owner, $new_db, string $contentType = self::contentTypes['adminDbCopy'][0])
    {
        $request = $this->adminDbCopyRequest($owner, $db, $new_owner, $new_db, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation adminDbCopyAsync
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $new_owner (required)
     * @param  string $new_db (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbCopy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminDbCopyAsync($owner, $db, $new_owner, $new_db, string $contentType = self::contentTypes['adminDbCopy'][0])
    {
        return $this->adminDbCopyAsyncWithHttpInfo($owner, $db, $new_owner, $new_db, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminDbCopyAsyncWithHttpInfo
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $new_owner (required)
     * @param  string $new_db (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbCopy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminDbCopyAsyncWithHttpInfo($owner, $db, $new_owner, $new_db, string $contentType = self::contentTypes['adminDbCopy'][0])
    {
        $returnType = '';
        $request = $this->adminDbCopyRequest($owner, $db, $new_owner, $new_db, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminDbCopy'
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $new_owner (required)
     * @param  string $new_db (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbCopy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminDbCopyRequest($owner, $db, $new_owner, $new_db, string $contentType = self::contentTypes['adminDbCopy'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling adminDbCopy'
            );
        }

        // verify the required parameter 'db' is set
        if ($db === null || (is_array($db) && count($db) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db when calling adminDbCopy'
            );
        }

        // verify the required parameter 'new_owner' is set
        if ($new_owner === null || (is_array($new_owner) && count($new_owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_owner when calling adminDbCopy'
            );
        }

        // verify the required parameter 'new_db' is set
        if ($new_db === null || (is_array($new_db) && count($new_db) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_db when calling adminDbCopy'
            );
        }


        $resourcePath = '/api/v1/admin/db/{owner}/{db}/copy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $new_owner,
            'new_owner', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $new_db,
            'new_db', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($db !== null) {
            $resourcePath = str_replace(
                '{' . 'db' . '}',
                ObjectSerializer::toPathValue($db),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminDbDelete
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbDelete'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminDbDelete($owner, $db, string $contentType = self::contentTypes['adminDbDelete'][0])
    {
        $this->adminDbDeleteWithHttpInfo($owner, $db, $contentType);
    }

    /**
     * Operation adminDbDeleteWithHttpInfo
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbDelete'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminDbDeleteWithHttpInfo($owner, $db, string $contentType = self::contentTypes['adminDbDelete'][0])
    {
        $request = $this->adminDbDeleteRequest($owner, $db, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation adminDbDeleteAsync
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminDbDeleteAsync($owner, $db, string $contentType = self::contentTypes['adminDbDelete'][0])
    {
        return $this->adminDbDeleteAsyncWithHttpInfo($owner, $db, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminDbDeleteAsyncWithHttpInfo
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminDbDeleteAsyncWithHttpInfo($owner, $db, string $contentType = self::contentTypes['adminDbDelete'][0])
    {
        $returnType = '';
        $request = $this->adminDbDeleteRequest($owner, $db, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminDbDelete'
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminDbDeleteRequest($owner, $db, string $contentType = self::contentTypes['adminDbDelete'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling adminDbDelete'
            );
        }

        // verify the required parameter 'db' is set
        if ($db === null || (is_array($db) && count($db) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db when calling adminDbDelete'
            );
        }


        $resourcePath = '/api/v1/admin/db/{owner}/{db}/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($db !== null) {
            $resourcePath = str_replace(
                '{' . 'db' . '}',
                ObjectSerializer::toPathValue($db),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminDbExec
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\QueryType[] $query_type query_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbExec'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Agnesoft\AgdbApi\Model\QueryResult[]
     */
    public function adminDbExec($owner, $db, $query_type, string $contentType = self::contentTypes['adminDbExec'][0])
    {
        list($response) = $this->adminDbExecWithHttpInfo($owner, $db, $query_type, $contentType);
        return $response;
    }

    /**
     * Operation adminDbExecWithHttpInfo
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\QueryType[] $query_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbExec'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Agnesoft\AgdbApi\Model\QueryResult[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminDbExecWithHttpInfo($owner, $db, $query_type, string $contentType = self::contentTypes['adminDbExec'][0])
    {
        $request = $this->adminDbExecRequest($owner, $db, $query_type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Agnesoft\AgdbApi\Model\QueryResult[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Agnesoft\AgdbApi\Model\QueryResult[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agnesoft\AgdbApi\Model\QueryResult[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation adminDbExecAsync
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\QueryType[] $query_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbExec'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminDbExecAsync($owner, $db, $query_type, string $contentType = self::contentTypes['adminDbExec'][0])
    {
        return $this->adminDbExecAsyncWithHttpInfo($owner, $db, $query_type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminDbExecAsyncWithHttpInfo
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\QueryType[] $query_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbExec'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminDbExecAsyncWithHttpInfo($owner, $db, $query_type, string $contentType = self::contentTypes['adminDbExec'][0])
    {
        $returnType = '\Agnesoft\AgdbApi\Model\QueryResult[]';
        $request = $this->adminDbExecRequest($owner, $db, $query_type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminDbExec'
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\QueryType[] $query_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbExec'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminDbExecRequest($owner, $db, $query_type, string $contentType = self::contentTypes['adminDbExec'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling adminDbExec'
            );
        }

        // verify the required parameter 'db' is set
        if ($db === null || (is_array($db) && count($db) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db when calling adminDbExec'
            );
        }

        // verify the required parameter 'query_type' is set
        if ($query_type === null || (is_array($query_type) && count($query_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query_type when calling adminDbExec'
            );
        }


        $resourcePath = '/api/v1/admin/db/{owner}/{db}/exec';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($db !== null) {
            $resourcePath = str_replace(
                '{' . 'db' . '}',
                ObjectSerializer::toPathValue($db),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($query_type)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($query_type));
            } else {
                $httpBody = $query_type;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminDbExecMut
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\QueryType[] $query_type query_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbExecMut'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Agnesoft\AgdbApi\Model\QueryResult[]
     */
    public function adminDbExecMut($owner, $db, $query_type, string $contentType = self::contentTypes['adminDbExecMut'][0])
    {
        list($response) = $this->adminDbExecMutWithHttpInfo($owner, $db, $query_type, $contentType);
        return $response;
    }

    /**
     * Operation adminDbExecMutWithHttpInfo
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\QueryType[] $query_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbExecMut'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Agnesoft\AgdbApi\Model\QueryResult[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminDbExecMutWithHttpInfo($owner, $db, $query_type, string $contentType = self::contentTypes['adminDbExecMut'][0])
    {
        $request = $this->adminDbExecMutRequest($owner, $db, $query_type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Agnesoft\AgdbApi\Model\QueryResult[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Agnesoft\AgdbApi\Model\QueryResult[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agnesoft\AgdbApi\Model\QueryResult[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation adminDbExecMutAsync
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\QueryType[] $query_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbExecMut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminDbExecMutAsync($owner, $db, $query_type, string $contentType = self::contentTypes['adminDbExecMut'][0])
    {
        return $this->adminDbExecMutAsyncWithHttpInfo($owner, $db, $query_type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminDbExecMutAsyncWithHttpInfo
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\QueryType[] $query_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbExecMut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminDbExecMutAsyncWithHttpInfo($owner, $db, $query_type, string $contentType = self::contentTypes['adminDbExecMut'][0])
    {
        $returnType = '\Agnesoft\AgdbApi\Model\QueryResult[]';
        $request = $this->adminDbExecMutRequest($owner, $db, $query_type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminDbExecMut'
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\QueryType[] $query_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbExecMut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminDbExecMutRequest($owner, $db, $query_type, string $contentType = self::contentTypes['adminDbExecMut'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling adminDbExecMut'
            );
        }

        // verify the required parameter 'db' is set
        if ($db === null || (is_array($db) && count($db) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db when calling adminDbExecMut'
            );
        }

        // verify the required parameter 'query_type' is set
        if ($query_type === null || (is_array($query_type) && count($query_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query_type when calling adminDbExecMut'
            );
        }


        $resourcePath = '/api/v1/admin/db/{owner}/{db}/exec_mut';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($db !== null) {
            $resourcePath = str_replace(
                '{' . 'db' . '}',
                ObjectSerializer::toPathValue($db),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($query_type)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($query_type));
            } else {
                $httpBody = $query_type;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminDbList
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbList'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Agnesoft\AgdbApi\Model\ServerDatabase[]
     */
    public function adminDbList(string $contentType = self::contentTypes['adminDbList'][0])
    {
        list($response) = $this->adminDbListWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation adminDbListWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbList'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Agnesoft\AgdbApi\Model\ServerDatabase[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminDbListWithHttpInfo(string $contentType = self::contentTypes['adminDbList'][0])
    {
        $request = $this->adminDbListRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Agnesoft\AgdbApi\Model\ServerDatabase[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Agnesoft\AgdbApi\Model\ServerDatabase[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agnesoft\AgdbApi\Model\ServerDatabase[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation adminDbListAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminDbListAsync(string $contentType = self::contentTypes['adminDbList'][0])
    {
        return $this->adminDbListAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminDbListAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminDbListAsyncWithHttpInfo(string $contentType = self::contentTypes['adminDbList'][0])
    {
        $returnType = '\Agnesoft\AgdbApi\Model\ServerDatabase[]';
        $request = $this->adminDbListRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminDbList'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminDbListRequest(string $contentType = self::contentTypes['adminDbList'][0])
    {


        $resourcePath = '/api/v1/admin/db/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminDbOptimize
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbOptimize'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Agnesoft\AgdbApi\Model\ServerDatabase
     */
    public function adminDbOptimize($owner, $db, string $contentType = self::contentTypes['adminDbOptimize'][0])
    {
        list($response) = $this->adminDbOptimizeWithHttpInfo($owner, $db, $contentType);
        return $response;
    }

    /**
     * Operation adminDbOptimizeWithHttpInfo
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbOptimize'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Agnesoft\AgdbApi\Model\ServerDatabase, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminDbOptimizeWithHttpInfo($owner, $db, string $contentType = self::contentTypes['adminDbOptimize'][0])
    {
        $request = $this->adminDbOptimizeRequest($owner, $db, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Agnesoft\AgdbApi\Model\ServerDatabase',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Agnesoft\AgdbApi\Model\ServerDatabase',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agnesoft\AgdbApi\Model\ServerDatabase',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation adminDbOptimizeAsync
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbOptimize'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminDbOptimizeAsync($owner, $db, string $contentType = self::contentTypes['adminDbOptimize'][0])
    {
        return $this->adminDbOptimizeAsyncWithHttpInfo($owner, $db, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminDbOptimizeAsyncWithHttpInfo
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbOptimize'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminDbOptimizeAsyncWithHttpInfo($owner, $db, string $contentType = self::contentTypes['adminDbOptimize'][0])
    {
        $returnType = '\Agnesoft\AgdbApi\Model\ServerDatabase';
        $request = $this->adminDbOptimizeRequest($owner, $db, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminDbOptimize'
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbOptimize'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminDbOptimizeRequest($owner, $db, string $contentType = self::contentTypes['adminDbOptimize'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling adminDbOptimize'
            );
        }

        // verify the required parameter 'db' is set
        if ($db === null || (is_array($db) && count($db) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db when calling adminDbOptimize'
            );
        }


        $resourcePath = '/api/v1/admin/db/{owner}/{db}/optimize';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($db !== null) {
            $resourcePath = str_replace(
                '{' . 'db' . '}',
                ObjectSerializer::toPathValue($db),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminDbRemove
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbRemove'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminDbRemove($owner, $db, string $contentType = self::contentTypes['adminDbRemove'][0])
    {
        $this->adminDbRemoveWithHttpInfo($owner, $db, $contentType);
    }

    /**
     * Operation adminDbRemoveWithHttpInfo
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbRemove'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminDbRemoveWithHttpInfo($owner, $db, string $contentType = self::contentTypes['adminDbRemove'][0])
    {
        $request = $this->adminDbRemoveRequest($owner, $db, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation adminDbRemoveAsync
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbRemove'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminDbRemoveAsync($owner, $db, string $contentType = self::contentTypes['adminDbRemove'][0])
    {
        return $this->adminDbRemoveAsyncWithHttpInfo($owner, $db, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminDbRemoveAsyncWithHttpInfo
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbRemove'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminDbRemoveAsyncWithHttpInfo($owner, $db, string $contentType = self::contentTypes['adminDbRemove'][0])
    {
        $returnType = '';
        $request = $this->adminDbRemoveRequest($owner, $db, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminDbRemove'
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbRemove'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminDbRemoveRequest($owner, $db, string $contentType = self::contentTypes['adminDbRemove'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling adminDbRemove'
            );
        }

        // verify the required parameter 'db' is set
        if ($db === null || (is_array($db) && count($db) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db when calling adminDbRemove'
            );
        }


        $resourcePath = '/api/v1/admin/db/{owner}/{db}/remove';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($db !== null) {
            $resourcePath = str_replace(
                '{' . 'db' . '}',
                ObjectSerializer::toPathValue($db),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminDbRename
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $new_owner new_owner (required)
     * @param  string $new_db new_db (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbRename'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminDbRename($owner, $db, $new_owner, $new_db, string $contentType = self::contentTypes['adminDbRename'][0])
    {
        $this->adminDbRenameWithHttpInfo($owner, $db, $new_owner, $new_db, $contentType);
    }

    /**
     * Operation adminDbRenameWithHttpInfo
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $new_owner (required)
     * @param  string $new_db (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbRename'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminDbRenameWithHttpInfo($owner, $db, $new_owner, $new_db, string $contentType = self::contentTypes['adminDbRename'][0])
    {
        $request = $this->adminDbRenameRequest($owner, $db, $new_owner, $new_db, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation adminDbRenameAsync
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $new_owner (required)
     * @param  string $new_db (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbRename'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminDbRenameAsync($owner, $db, $new_owner, $new_db, string $contentType = self::contentTypes['adminDbRename'][0])
    {
        return $this->adminDbRenameAsyncWithHttpInfo($owner, $db, $new_owner, $new_db, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminDbRenameAsyncWithHttpInfo
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $new_owner (required)
     * @param  string $new_db (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbRename'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminDbRenameAsyncWithHttpInfo($owner, $db, $new_owner, $new_db, string $contentType = self::contentTypes['adminDbRename'][0])
    {
        $returnType = '';
        $request = $this->adminDbRenameRequest($owner, $db, $new_owner, $new_db, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminDbRename'
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $new_owner (required)
     * @param  string $new_db (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbRename'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminDbRenameRequest($owner, $db, $new_owner, $new_db, string $contentType = self::contentTypes['adminDbRename'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling adminDbRename'
            );
        }

        // verify the required parameter 'db' is set
        if ($db === null || (is_array($db) && count($db) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db when calling adminDbRename'
            );
        }

        // verify the required parameter 'new_owner' is set
        if ($new_owner === null || (is_array($new_owner) && count($new_owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_owner when calling adminDbRename'
            );
        }

        // verify the required parameter 'new_db' is set
        if ($new_db === null || (is_array($new_db) && count($new_db) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_db when calling adminDbRename'
            );
        }


        $resourcePath = '/api/v1/admin/db/{owner}/{db}/rename';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $new_owner,
            'new_owner', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $new_db,
            'new_db', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($db !== null) {
            $resourcePath = str_replace(
                '{' . 'db' . '}',
                ObjectSerializer::toPathValue($db),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminDbRestore
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbRestore'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminDbRestore($owner, $db, string $contentType = self::contentTypes['adminDbRestore'][0])
    {
        $this->adminDbRestoreWithHttpInfo($owner, $db, $contentType);
    }

    /**
     * Operation adminDbRestoreWithHttpInfo
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbRestore'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminDbRestoreWithHttpInfo($owner, $db, string $contentType = self::contentTypes['adminDbRestore'][0])
    {
        $request = $this->adminDbRestoreRequest($owner, $db, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation adminDbRestoreAsync
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbRestore'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminDbRestoreAsync($owner, $db, string $contentType = self::contentTypes['adminDbRestore'][0])
    {
        return $this->adminDbRestoreAsyncWithHttpInfo($owner, $db, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminDbRestoreAsyncWithHttpInfo
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbRestore'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminDbRestoreAsyncWithHttpInfo($owner, $db, string $contentType = self::contentTypes['adminDbRestore'][0])
    {
        $returnType = '';
        $request = $this->adminDbRestoreRequest($owner, $db, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminDbRestore'
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbRestore'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminDbRestoreRequest($owner, $db, string $contentType = self::contentTypes['adminDbRestore'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling adminDbRestore'
            );
        }

        // verify the required parameter 'db' is set
        if ($db === null || (is_array($db) && count($db) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db when calling adminDbRestore'
            );
        }


        $resourcePath = '/api/v1/admin/db/{owner}/{db}/restore';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($db !== null) {
            $resourcePath = str_replace(
                '{' . 'db' . '}',
                ObjectSerializer::toPathValue($db),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminDbUserAdd
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $username user name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbUserRole $db_role db_role (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbUserAdd'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminDbUserAdd($owner, $db, $username, $db_role, string $contentType = self::contentTypes['adminDbUserAdd'][0])
    {
        $this->adminDbUserAddWithHttpInfo($owner, $db, $username, $db_role, $contentType);
    }

    /**
     * Operation adminDbUserAddWithHttpInfo
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $username user name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbUserRole $db_role (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbUserAdd'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminDbUserAddWithHttpInfo($owner, $db, $username, $db_role, string $contentType = self::contentTypes['adminDbUserAdd'][0])
    {
        $request = $this->adminDbUserAddRequest($owner, $db, $username, $db_role, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation adminDbUserAddAsync
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $username user name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbUserRole $db_role (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbUserAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminDbUserAddAsync($owner, $db, $username, $db_role, string $contentType = self::contentTypes['adminDbUserAdd'][0])
    {
        return $this->adminDbUserAddAsyncWithHttpInfo($owner, $db, $username, $db_role, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminDbUserAddAsyncWithHttpInfo
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $username user name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbUserRole $db_role (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbUserAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminDbUserAddAsyncWithHttpInfo($owner, $db, $username, $db_role, string $contentType = self::contentTypes['adminDbUserAdd'][0])
    {
        $returnType = '';
        $request = $this->adminDbUserAddRequest($owner, $db, $username, $db_role, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminDbUserAdd'
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $username user name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbUserRole $db_role (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbUserAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminDbUserAddRequest($owner, $db, $username, $db_role, string $contentType = self::contentTypes['adminDbUserAdd'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling adminDbUserAdd'
            );
        }

        // verify the required parameter 'db' is set
        if ($db === null || (is_array($db) && count($db) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db when calling adminDbUserAdd'
            );
        }

        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling adminDbUserAdd'
            );
        }

        // verify the required parameter 'db_role' is set
        if ($db_role === null || (is_array($db_role) && count($db_role) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db_role when calling adminDbUserAdd'
            );
        }


        $resourcePath = '/api/v1/admin/db/{owner}/{db}/user/{username}/add';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $db_role,
            'db_role', // param base name
            'DbUserRole', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($db !== null) {
            $resourcePath = str_replace(
                '{' . 'db' . '}',
                ObjectSerializer::toPathValue($db),
                $resourcePath
            );
        }
        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminDbUserList
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbUserList'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Agnesoft\AgdbApi\Model\DbUser[]
     */
    public function adminDbUserList($owner, $db, string $contentType = self::contentTypes['adminDbUserList'][0])
    {
        list($response) = $this->adminDbUserListWithHttpInfo($owner, $db, $contentType);
        return $response;
    }

    /**
     * Operation adminDbUserListWithHttpInfo
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbUserList'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Agnesoft\AgdbApi\Model\DbUser[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminDbUserListWithHttpInfo($owner, $db, string $contentType = self::contentTypes['adminDbUserList'][0])
    {
        $request = $this->adminDbUserListRequest($owner, $db, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Agnesoft\AgdbApi\Model\DbUser[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Agnesoft\AgdbApi\Model\DbUser[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agnesoft\AgdbApi\Model\DbUser[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation adminDbUserListAsync
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbUserList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminDbUserListAsync($owner, $db, string $contentType = self::contentTypes['adminDbUserList'][0])
    {
        return $this->adminDbUserListAsyncWithHttpInfo($owner, $db, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminDbUserListAsyncWithHttpInfo
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbUserList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminDbUserListAsyncWithHttpInfo($owner, $db, string $contentType = self::contentTypes['adminDbUserList'][0])
    {
        $returnType = '\Agnesoft\AgdbApi\Model\DbUser[]';
        $request = $this->adminDbUserListRequest($owner, $db, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminDbUserList'
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbUserList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminDbUserListRequest($owner, $db, string $contentType = self::contentTypes['adminDbUserList'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling adminDbUserList'
            );
        }

        // verify the required parameter 'db' is set
        if ($db === null || (is_array($db) && count($db) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db when calling adminDbUserList'
            );
        }


        $resourcePath = '/api/v1/admin/db/{owner}/{db}/user/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($db !== null) {
            $resourcePath = str_replace(
                '{' . 'db' . '}',
                ObjectSerializer::toPathValue($db),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminDbUserRemove
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $username user name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbUserRemove'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminDbUserRemove($owner, $db, $username, string $contentType = self::contentTypes['adminDbUserRemove'][0])
    {
        $this->adminDbUserRemoveWithHttpInfo($owner, $db, $username, $contentType);
    }

    /**
     * Operation adminDbUserRemoveWithHttpInfo
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $username user name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbUserRemove'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminDbUserRemoveWithHttpInfo($owner, $db, $username, string $contentType = self::contentTypes['adminDbUserRemove'][0])
    {
        $request = $this->adminDbUserRemoveRequest($owner, $db, $username, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation adminDbUserRemoveAsync
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $username user name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbUserRemove'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminDbUserRemoveAsync($owner, $db, $username, string $contentType = self::contentTypes['adminDbUserRemove'][0])
    {
        return $this->adminDbUserRemoveAsyncWithHttpInfo($owner, $db, $username, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminDbUserRemoveAsyncWithHttpInfo
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $username user name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbUserRemove'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminDbUserRemoveAsyncWithHttpInfo($owner, $db, $username, string $contentType = self::contentTypes['adminDbUserRemove'][0])
    {
        $returnType = '';
        $request = $this->adminDbUserRemoveRequest($owner, $db, $username, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminDbUserRemove'
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $username user name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminDbUserRemove'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminDbUserRemoveRequest($owner, $db, $username, string $contentType = self::contentTypes['adminDbUserRemove'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling adminDbUserRemove'
            );
        }

        // verify the required parameter 'db' is set
        if ($db === null || (is_array($db) && count($db) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db when calling adminDbUserRemove'
            );
        }

        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling adminDbUserRemove'
            );
        }


        $resourcePath = '/api/v1/admin/db/{owner}/{db}/user/{username}/remove';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($db !== null) {
            $resourcePath = str_replace(
                '{' . 'db' . '}',
                ObjectSerializer::toPathValue($db),
                $resourcePath
            );
        }
        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminShutdown
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminShutdown'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminShutdown(string $contentType = self::contentTypes['adminShutdown'][0])
    {
        $this->adminShutdownWithHttpInfo($contentType);
    }

    /**
     * Operation adminShutdownWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminShutdown'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminShutdownWithHttpInfo(string $contentType = self::contentTypes['adminShutdown'][0])
    {
        $request = $this->adminShutdownRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation adminShutdownAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminShutdown'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminShutdownAsync(string $contentType = self::contentTypes['adminShutdown'][0])
    {
        return $this->adminShutdownAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminShutdownAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminShutdown'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminShutdownAsyncWithHttpInfo(string $contentType = self::contentTypes['adminShutdown'][0])
    {
        $returnType = '';
        $request = $this->adminShutdownRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminShutdown'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminShutdown'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminShutdownRequest(string $contentType = self::contentTypes['adminShutdown'][0])
    {


        $resourcePath = '/api/v1/admin/shutdown';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminStatus
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminStatus'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Agnesoft\AgdbApi\Model\AdminStatus
     */
    public function adminStatus(string $contentType = self::contentTypes['adminStatus'][0])
    {
        list($response) = $this->adminStatusWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation adminStatusWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminStatus'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Agnesoft\AgdbApi\Model\AdminStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminStatusWithHttpInfo(string $contentType = self::contentTypes['adminStatus'][0])
    {
        $request = $this->adminStatusRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Agnesoft\AgdbApi\Model\AdminStatus',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Agnesoft\AgdbApi\Model\AdminStatus',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agnesoft\AgdbApi\Model\AdminStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation adminStatusAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminStatusAsync(string $contentType = self::contentTypes['adminStatus'][0])
    {
        return $this->adminStatusAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminStatusAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminStatusAsyncWithHttpInfo(string $contentType = self::contentTypes['adminStatus'][0])
    {
        $returnType = '\Agnesoft\AgdbApi\Model\AdminStatus';
        $request = $this->adminStatusRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminStatus'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminStatusRequest(string $contentType = self::contentTypes['adminStatus'][0])
    {


        $resourcePath = '/api/v1/admin/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminUserAdd
     *
     * @param  string $username desired user name (required)
     * @param  \Agnesoft\AgdbApi\Model\UserCredentials $user_credentials user_credentials (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminUserAdd'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminUserAdd($username, $user_credentials, string $contentType = self::contentTypes['adminUserAdd'][0])
    {
        $this->adminUserAddWithHttpInfo($username, $user_credentials, $contentType);
    }

    /**
     * Operation adminUserAddWithHttpInfo
     *
     * @param  string $username desired user name (required)
     * @param  \Agnesoft\AgdbApi\Model\UserCredentials $user_credentials (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminUserAdd'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminUserAddWithHttpInfo($username, $user_credentials, string $contentType = self::contentTypes['adminUserAdd'][0])
    {
        $request = $this->adminUserAddRequest($username, $user_credentials, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation adminUserAddAsync
     *
     * @param  string $username desired user name (required)
     * @param  \Agnesoft\AgdbApi\Model\UserCredentials $user_credentials (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminUserAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminUserAddAsync($username, $user_credentials, string $contentType = self::contentTypes['adminUserAdd'][0])
    {
        return $this->adminUserAddAsyncWithHttpInfo($username, $user_credentials, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminUserAddAsyncWithHttpInfo
     *
     * @param  string $username desired user name (required)
     * @param  \Agnesoft\AgdbApi\Model\UserCredentials $user_credentials (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminUserAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminUserAddAsyncWithHttpInfo($username, $user_credentials, string $contentType = self::contentTypes['adminUserAdd'][0])
    {
        $returnType = '';
        $request = $this->adminUserAddRequest($username, $user_credentials, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminUserAdd'
     *
     * @param  string $username desired user name (required)
     * @param  \Agnesoft\AgdbApi\Model\UserCredentials $user_credentials (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminUserAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminUserAddRequest($username, $user_credentials, string $contentType = self::contentTypes['adminUserAdd'][0])
    {

        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling adminUserAdd'
            );
        }

        // verify the required parameter 'user_credentials' is set
        if ($user_credentials === null || (is_array($user_credentials) && count($user_credentials) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_credentials when calling adminUserAdd'
            );
        }


        $resourcePath = '/api/v1/admin/user/{username}/add';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($user_credentials)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($user_credentials));
            } else {
                $httpBody = $user_credentials;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminUserChangePassword
     *
     * @param  string $username user name (required)
     * @param  \Agnesoft\AgdbApi\Model\UserCredentials $user_credentials user_credentials (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminUserChangePassword'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminUserChangePassword($username, $user_credentials, string $contentType = self::contentTypes['adminUserChangePassword'][0])
    {
        $this->adminUserChangePasswordWithHttpInfo($username, $user_credentials, $contentType);
    }

    /**
     * Operation adminUserChangePasswordWithHttpInfo
     *
     * @param  string $username user name (required)
     * @param  \Agnesoft\AgdbApi\Model\UserCredentials $user_credentials (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminUserChangePassword'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminUserChangePasswordWithHttpInfo($username, $user_credentials, string $contentType = self::contentTypes['adminUserChangePassword'][0])
    {
        $request = $this->adminUserChangePasswordRequest($username, $user_credentials, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation adminUserChangePasswordAsync
     *
     * @param  string $username user name (required)
     * @param  \Agnesoft\AgdbApi\Model\UserCredentials $user_credentials (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminUserChangePassword'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminUserChangePasswordAsync($username, $user_credentials, string $contentType = self::contentTypes['adminUserChangePassword'][0])
    {
        return $this->adminUserChangePasswordAsyncWithHttpInfo($username, $user_credentials, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminUserChangePasswordAsyncWithHttpInfo
     *
     * @param  string $username user name (required)
     * @param  \Agnesoft\AgdbApi\Model\UserCredentials $user_credentials (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminUserChangePassword'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminUserChangePasswordAsyncWithHttpInfo($username, $user_credentials, string $contentType = self::contentTypes['adminUserChangePassword'][0])
    {
        $returnType = '';
        $request = $this->adminUserChangePasswordRequest($username, $user_credentials, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminUserChangePassword'
     *
     * @param  string $username user name (required)
     * @param  \Agnesoft\AgdbApi\Model\UserCredentials $user_credentials (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminUserChangePassword'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminUserChangePasswordRequest($username, $user_credentials, string $contentType = self::contentTypes['adminUserChangePassword'][0])
    {

        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling adminUserChangePassword'
            );
        }

        // verify the required parameter 'user_credentials' is set
        if ($user_credentials === null || (is_array($user_credentials) && count($user_credentials) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_credentials when calling adminUserChangePassword'
            );
        }


        $resourcePath = '/api/v1/admin/user/{username}/change_password';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($user_credentials)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($user_credentials));
            } else {
                $httpBody = $user_credentials;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminUserDelete
     *
     * @param  string $username user name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminUserDelete'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Agnesoft\AgdbApi\Model\UserStatus[]
     */
    public function adminUserDelete($username, string $contentType = self::contentTypes['adminUserDelete'][0])
    {
        list($response) = $this->adminUserDeleteWithHttpInfo($username, $contentType);
        return $response;
    }

    /**
     * Operation adminUserDeleteWithHttpInfo
     *
     * @param  string $username user name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminUserDelete'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Agnesoft\AgdbApi\Model\UserStatus[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminUserDeleteWithHttpInfo($username, string $contentType = self::contentTypes['adminUserDelete'][0])
    {
        $request = $this->adminUserDeleteRequest($username, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 204:
                    return $this->handleResponseWithDataType(
                        '\Agnesoft\AgdbApi\Model\UserStatus[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Agnesoft\AgdbApi\Model\UserStatus[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agnesoft\AgdbApi\Model\UserStatus[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation adminUserDeleteAsync
     *
     * @param  string $username user name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminUserDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminUserDeleteAsync($username, string $contentType = self::contentTypes['adminUserDelete'][0])
    {
        return $this->adminUserDeleteAsyncWithHttpInfo($username, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminUserDeleteAsyncWithHttpInfo
     *
     * @param  string $username user name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminUserDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminUserDeleteAsyncWithHttpInfo($username, string $contentType = self::contentTypes['adminUserDelete'][0])
    {
        $returnType = '\Agnesoft\AgdbApi\Model\UserStatus[]';
        $request = $this->adminUserDeleteRequest($username, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminUserDelete'
     *
     * @param  string $username user name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminUserDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminUserDeleteRequest($username, string $contentType = self::contentTypes['adminUserDelete'][0])
    {

        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling adminUserDelete'
            );
        }


        $resourcePath = '/api/v1/admin/user/{username}/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminUserList
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminUserList'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Agnesoft\AgdbApi\Model\UserStatus[]
     */
    public function adminUserList(string $contentType = self::contentTypes['adminUserList'][0])
    {
        list($response) = $this->adminUserListWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation adminUserListWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminUserList'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Agnesoft\AgdbApi\Model\UserStatus[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminUserListWithHttpInfo(string $contentType = self::contentTypes['adminUserList'][0])
    {
        $request = $this->adminUserListRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Agnesoft\AgdbApi\Model\UserStatus[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Agnesoft\AgdbApi\Model\UserStatus[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agnesoft\AgdbApi\Model\UserStatus[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation adminUserListAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminUserList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminUserListAsync(string $contentType = self::contentTypes['adminUserList'][0])
    {
        return $this->adminUserListAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminUserListAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminUserList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminUserListAsyncWithHttpInfo(string $contentType = self::contentTypes['adminUserList'][0])
    {
        $returnType = '\Agnesoft\AgdbApi\Model\UserStatus[]';
        $request = $this->adminUserListRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminUserList'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminUserList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminUserListRequest(string $contentType = self::contentTypes['adminUserList'][0])
    {


        $resourcePath = '/api/v1/admin/user/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminUserLogout
     *
     * @param  string $username user name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminUserLogout'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminUserLogout($username, string $contentType = self::contentTypes['adminUserLogout'][0])
    {
        $this->adminUserLogoutWithHttpInfo($username, $contentType);
    }

    /**
     * Operation adminUserLogoutWithHttpInfo
     *
     * @param  string $username user name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminUserLogout'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminUserLogoutWithHttpInfo($username, string $contentType = self::contentTypes['adminUserLogout'][0])
    {
        $request = $this->adminUserLogoutRequest($username, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation adminUserLogoutAsync
     *
     * @param  string $username user name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminUserLogout'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminUserLogoutAsync($username, string $contentType = self::contentTypes['adminUserLogout'][0])
    {
        return $this->adminUserLogoutAsyncWithHttpInfo($username, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminUserLogoutAsyncWithHttpInfo
     *
     * @param  string $username user name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminUserLogout'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminUserLogoutAsyncWithHttpInfo($username, string $contentType = self::contentTypes['adminUserLogout'][0])
    {
        $returnType = '';
        $request = $this->adminUserLogoutRequest($username, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminUserLogout'
     *
     * @param  string $username user name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminUserLogout'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminUserLogoutRequest($username, string $contentType = self::contentTypes['adminUserLogout'][0])
    {

        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling adminUserLogout'
            );
        }


        $resourcePath = '/api/v1/admin/user/{username}/logout';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminUserLogoutAll
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminUserLogoutAll'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminUserLogoutAll(string $contentType = self::contentTypes['adminUserLogoutAll'][0])
    {
        $this->adminUserLogoutAllWithHttpInfo($contentType);
    }

    /**
     * Operation adminUserLogoutAllWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminUserLogoutAll'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminUserLogoutAllWithHttpInfo(string $contentType = self::contentTypes['adminUserLogoutAll'][0])
    {
        $request = $this->adminUserLogoutAllRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation adminUserLogoutAllAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminUserLogoutAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminUserLogoutAllAsync(string $contentType = self::contentTypes['adminUserLogoutAll'][0])
    {
        return $this->adminUserLogoutAllAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminUserLogoutAllAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminUserLogoutAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminUserLogoutAllAsyncWithHttpInfo(string $contentType = self::contentTypes['adminUserLogoutAll'][0])
    {
        $returnType = '';
        $request = $this->adminUserLogoutAllRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminUserLogoutAll'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminUserLogoutAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminUserLogoutAllRequest(string $contentType = self::contentTypes['adminUserLogoutAll'][0])
    {


        $resourcePath = '/api/v1/admin/user/logout_all';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clusterAdminUserLogout
     *
     * @param  string $username user name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clusterAdminUserLogout'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clusterAdminUserLogout($username, string $contentType = self::contentTypes['clusterAdminUserLogout'][0])
    {
        $this->clusterAdminUserLogoutWithHttpInfo($username, $contentType);
    }

    /**
     * Operation clusterAdminUserLogoutWithHttpInfo
     *
     * @param  string $username user name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clusterAdminUserLogout'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clusterAdminUserLogoutWithHttpInfo($username, string $contentType = self::contentTypes['clusterAdminUserLogout'][0])
    {
        $request = $this->clusterAdminUserLogoutRequest($username, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation clusterAdminUserLogoutAsync
     *
     * @param  string $username user name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clusterAdminUserLogout'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clusterAdminUserLogoutAsync($username, string $contentType = self::contentTypes['clusterAdminUserLogout'][0])
    {
        return $this->clusterAdminUserLogoutAsyncWithHttpInfo($username, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clusterAdminUserLogoutAsyncWithHttpInfo
     *
     * @param  string $username user name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clusterAdminUserLogout'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clusterAdminUserLogoutAsyncWithHttpInfo($username, string $contentType = self::contentTypes['clusterAdminUserLogout'][0])
    {
        $returnType = '';
        $request = $this->clusterAdminUserLogoutRequest($username, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clusterAdminUserLogout'
     *
     * @param  string $username user name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clusterAdminUserLogout'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clusterAdminUserLogoutRequest($username, string $contentType = self::contentTypes['clusterAdminUserLogout'][0])
    {

        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling clusterAdminUserLogout'
            );
        }


        $resourcePath = '/api/v1/cluster/admin/user/{username}/logout';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clusterAdminUserLogoutAll
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clusterAdminUserLogoutAll'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clusterAdminUserLogoutAll(string $contentType = self::contentTypes['clusterAdminUserLogoutAll'][0])
    {
        $this->clusterAdminUserLogoutAllWithHttpInfo($contentType);
    }

    /**
     * Operation clusterAdminUserLogoutAllWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clusterAdminUserLogoutAll'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clusterAdminUserLogoutAllWithHttpInfo(string $contentType = self::contentTypes['clusterAdminUserLogoutAll'][0])
    {
        $request = $this->clusterAdminUserLogoutAllRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation clusterAdminUserLogoutAllAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clusterAdminUserLogoutAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clusterAdminUserLogoutAllAsync(string $contentType = self::contentTypes['clusterAdminUserLogoutAll'][0])
    {
        return $this->clusterAdminUserLogoutAllAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clusterAdminUserLogoutAllAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clusterAdminUserLogoutAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clusterAdminUserLogoutAllAsyncWithHttpInfo(string $contentType = self::contentTypes['clusterAdminUserLogoutAll'][0])
    {
        $returnType = '';
        $request = $this->clusterAdminUserLogoutAllRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clusterAdminUserLogoutAll'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clusterAdminUserLogoutAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clusterAdminUserLogoutAllRequest(string $contentType = self::contentTypes['clusterAdminUserLogoutAll'][0])
    {


        $resourcePath = '/api/v1/cluster/admin/user/logout_all';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clusterStatus
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clusterStatus'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Agnesoft\AgdbApi\Model\ClusterStatus[]
     */
    public function clusterStatus(string $contentType = self::contentTypes['clusterStatus'][0])
    {
        list($response) = $this->clusterStatusWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation clusterStatusWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clusterStatus'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Agnesoft\AgdbApi\Model\ClusterStatus[], HTTP status code, HTTP response headers (array of strings)
     */
    public function clusterStatusWithHttpInfo(string $contentType = self::contentTypes['clusterStatus'][0])
    {
        $request = $this->clusterStatusRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Agnesoft\AgdbApi\Model\ClusterStatus[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Agnesoft\AgdbApi\Model\ClusterStatus[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agnesoft\AgdbApi\Model\ClusterStatus[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation clusterStatusAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clusterStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clusterStatusAsync(string $contentType = self::contentTypes['clusterStatus'][0])
    {
        return $this->clusterStatusAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clusterStatusAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clusterStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clusterStatusAsyncWithHttpInfo(string $contentType = self::contentTypes['clusterStatus'][0])
    {
        $returnType = '\Agnesoft\AgdbApi\Model\ClusterStatus[]';
        $request = $this->clusterStatusRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clusterStatus'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clusterStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clusterStatusRequest(string $contentType = self::contentTypes['clusterStatus'][0])
    {


        $resourcePath = '/api/v1/cluster/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clusterUserLogin
     *
     * @param  \Agnesoft\AgdbApi\Model\UserLogin $user_login user_login (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clusterUserLogin'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return string
     */
    public function clusterUserLogin($user_login, string $contentType = self::contentTypes['clusterUserLogin'][0])
    {
        list($response) = $this->clusterUserLoginWithHttpInfo($user_login, $contentType);
        return $response;
    }

    /**
     * Operation clusterUserLoginWithHttpInfo
     *
     * @param  \Agnesoft\AgdbApi\Model\UserLogin $user_login (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clusterUserLogin'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function clusterUserLoginWithHttpInfo($user_login, string $contentType = self::contentTypes['clusterUserLogin'][0])
    {
        $request = $this->clusterUserLoginRequest($user_login, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'string',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'string',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation clusterUserLoginAsync
     *
     * @param  \Agnesoft\AgdbApi\Model\UserLogin $user_login (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clusterUserLogin'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clusterUserLoginAsync($user_login, string $contentType = self::contentTypes['clusterUserLogin'][0])
    {
        return $this->clusterUserLoginAsyncWithHttpInfo($user_login, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clusterUserLoginAsyncWithHttpInfo
     *
     * @param  \Agnesoft\AgdbApi\Model\UserLogin $user_login (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clusterUserLogin'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clusterUserLoginAsyncWithHttpInfo($user_login, string $contentType = self::contentTypes['clusterUserLogin'][0])
    {
        $returnType = 'string';
        $request = $this->clusterUserLoginRequest($user_login, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clusterUserLogin'
     *
     * @param  \Agnesoft\AgdbApi\Model\UserLogin $user_login (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clusterUserLogin'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clusterUserLoginRequest($user_login, string $contentType = self::contentTypes['clusterUserLogin'][0])
    {

        // verify the required parameter 'user_login' is set
        if ($user_login === null || (is_array($user_login) && count($user_login) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_login when calling clusterUserLogin'
            );
        }


        $resourcePath = '/api/v1/cluster/user/login';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($user_login)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($user_login));
            } else {
                $httpBody = $user_login;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clusterUserLogout
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clusterUserLogout'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clusterUserLogout(string $contentType = self::contentTypes['clusterUserLogout'][0])
    {
        $this->clusterUserLogoutWithHttpInfo($contentType);
    }

    /**
     * Operation clusterUserLogoutWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clusterUserLogout'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clusterUserLogoutWithHttpInfo(string $contentType = self::contentTypes['clusterUserLogout'][0])
    {
        $request = $this->clusterUserLogoutRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation clusterUserLogoutAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clusterUserLogout'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clusterUserLogoutAsync(string $contentType = self::contentTypes['clusterUserLogout'][0])
    {
        return $this->clusterUserLogoutAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clusterUserLogoutAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clusterUserLogout'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clusterUserLogoutAsyncWithHttpInfo(string $contentType = self::contentTypes['clusterUserLogout'][0])
    {
        $returnType = '';
        $request = $this->clusterUserLogoutRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clusterUserLogout'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clusterUserLogout'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clusterUserLogoutRequest(string $contentType = self::contentTypes['clusterUserLogout'][0])
    {


        $resourcePath = '/api/v1/cluster/user/logout';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dbAdd
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbType $db_type db_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbAdd'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function dbAdd($owner, $db, $db_type, string $contentType = self::contentTypes['dbAdd'][0])
    {
        $this->dbAddWithHttpInfo($owner, $db, $db_type, $contentType);
    }

    /**
     * Operation dbAddWithHttpInfo
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbType $db_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbAdd'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function dbAddWithHttpInfo($owner, $db, $db_type, string $contentType = self::contentTypes['dbAdd'][0])
    {
        $request = $this->dbAddRequest($owner, $db, $db_type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation dbAddAsync
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbType $db_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dbAddAsync($owner, $db, $db_type, string $contentType = self::contentTypes['dbAdd'][0])
    {
        return $this->dbAddAsyncWithHttpInfo($owner, $db, $db_type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dbAddAsyncWithHttpInfo
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbType $db_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dbAddAsyncWithHttpInfo($owner, $db, $db_type, string $contentType = self::contentTypes['dbAdd'][0])
    {
        $returnType = '';
        $request = $this->dbAddRequest($owner, $db, $db_type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dbAdd'
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbType $db_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function dbAddRequest($owner, $db, $db_type, string $contentType = self::contentTypes['dbAdd'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling dbAdd'
            );
        }

        // verify the required parameter 'db' is set
        if ($db === null || (is_array($db) && count($db) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db when calling dbAdd'
            );
        }

        // verify the required parameter 'db_type' is set
        if ($db_type === null || (is_array($db_type) && count($db_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db_type when calling dbAdd'
            );
        }


        $resourcePath = '/api/v1/db/{owner}/{db}/add';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $db_type,
            'db_type', // param base name
            'DbType', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($db !== null) {
            $resourcePath = str_replace(
                '{' . 'db' . '}',
                ObjectSerializer::toPathValue($db),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dbAudit
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbAudit'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Agnesoft\AgdbApi\Model\QueryAudit[]
     */
    public function dbAudit($owner, $db, string $contentType = self::contentTypes['dbAudit'][0])
    {
        list($response) = $this->dbAuditWithHttpInfo($owner, $db, $contentType);
        return $response;
    }

    /**
     * Operation dbAuditWithHttpInfo
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbAudit'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Agnesoft\AgdbApi\Model\QueryAudit[], HTTP status code, HTTP response headers (array of strings)
     */
    public function dbAuditWithHttpInfo($owner, $db, string $contentType = self::contentTypes['dbAudit'][0])
    {
        $request = $this->dbAuditRequest($owner, $db, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Agnesoft\AgdbApi\Model\QueryAudit[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Agnesoft\AgdbApi\Model\QueryAudit[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agnesoft\AgdbApi\Model\QueryAudit[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation dbAuditAsync
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbAudit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dbAuditAsync($owner, $db, string $contentType = self::contentTypes['dbAudit'][0])
    {
        return $this->dbAuditAsyncWithHttpInfo($owner, $db, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dbAuditAsyncWithHttpInfo
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbAudit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dbAuditAsyncWithHttpInfo($owner, $db, string $contentType = self::contentTypes['dbAudit'][0])
    {
        $returnType = '\Agnesoft\AgdbApi\Model\QueryAudit[]';
        $request = $this->dbAuditRequest($owner, $db, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dbAudit'
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbAudit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function dbAuditRequest($owner, $db, string $contentType = self::contentTypes['dbAudit'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling dbAudit'
            );
        }

        // verify the required parameter 'db' is set
        if ($db === null || (is_array($db) && count($db) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db when calling dbAudit'
            );
        }


        $resourcePath = '/api/v1/db/{owner}/{db}/audit';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($db !== null) {
            $resourcePath = str_replace(
                '{' . 'db' . '}',
                ObjectSerializer::toPathValue($db),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dbBackup
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbBackup'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function dbBackup($owner, $db, string $contentType = self::contentTypes['dbBackup'][0])
    {
        $this->dbBackupWithHttpInfo($owner, $db, $contentType);
    }

    /**
     * Operation dbBackupWithHttpInfo
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbBackup'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function dbBackupWithHttpInfo($owner, $db, string $contentType = self::contentTypes['dbBackup'][0])
    {
        $request = $this->dbBackupRequest($owner, $db, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation dbBackupAsync
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbBackup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dbBackupAsync($owner, $db, string $contentType = self::contentTypes['dbBackup'][0])
    {
        return $this->dbBackupAsyncWithHttpInfo($owner, $db, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dbBackupAsyncWithHttpInfo
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbBackup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dbBackupAsyncWithHttpInfo($owner, $db, string $contentType = self::contentTypes['dbBackup'][0])
    {
        $returnType = '';
        $request = $this->dbBackupRequest($owner, $db, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dbBackup'
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbBackup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function dbBackupRequest($owner, $db, string $contentType = self::contentTypes['dbBackup'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling dbBackup'
            );
        }

        // verify the required parameter 'db' is set
        if ($db === null || (is_array($db) && count($db) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db when calling dbBackup'
            );
        }


        $resourcePath = '/api/v1/db/{owner}/{db}/backup';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($db !== null) {
            $resourcePath = str_replace(
                '{' . 'db' . '}',
                ObjectSerializer::toPathValue($db),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dbClear
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbResource $resource resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbClear'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Agnesoft\AgdbApi\Model\ServerDatabase
     */
    public function dbClear($owner, $db, $resource, string $contentType = self::contentTypes['dbClear'][0])
    {
        list($response) = $this->dbClearWithHttpInfo($owner, $db, $resource, $contentType);
        return $response;
    }

    /**
     * Operation dbClearWithHttpInfo
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbResource $resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbClear'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Agnesoft\AgdbApi\Model\ServerDatabase, HTTP status code, HTTP response headers (array of strings)
     */
    public function dbClearWithHttpInfo($owner, $db, $resource, string $contentType = self::contentTypes['dbClear'][0])
    {
        $request = $this->dbClearRequest($owner, $db, $resource, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\Agnesoft\AgdbApi\Model\ServerDatabase',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Agnesoft\AgdbApi\Model\ServerDatabase',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agnesoft\AgdbApi\Model\ServerDatabase',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation dbClearAsync
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbResource $resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbClear'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dbClearAsync($owner, $db, $resource, string $contentType = self::contentTypes['dbClear'][0])
    {
        return $this->dbClearAsyncWithHttpInfo($owner, $db, $resource, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dbClearAsyncWithHttpInfo
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbResource $resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbClear'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dbClearAsyncWithHttpInfo($owner, $db, $resource, string $contentType = self::contentTypes['dbClear'][0])
    {
        $returnType = '\Agnesoft\AgdbApi\Model\ServerDatabase';
        $request = $this->dbClearRequest($owner, $db, $resource, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dbClear'
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbResource $resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbClear'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function dbClearRequest($owner, $db, $resource, string $contentType = self::contentTypes['dbClear'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling dbClear'
            );
        }

        // verify the required parameter 'db' is set
        if ($db === null || (is_array($db) && count($db) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db when calling dbClear'
            );
        }

        // verify the required parameter 'resource' is set
        if ($resource === null || (is_array($resource) && count($resource) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource when calling dbClear'
            );
        }


        $resourcePath = '/api/v1/db/{owner}/{db}/clear';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $resource,
            'resource', // param base name
            'DbResource', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($db !== null) {
            $resourcePath = str_replace(
                '{' . 'db' . '}',
                ObjectSerializer::toPathValue($db),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dbConvert
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbType $db_type db_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbConvert'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function dbConvert($owner, $db, $db_type, string $contentType = self::contentTypes['dbConvert'][0])
    {
        $this->dbConvertWithHttpInfo($owner, $db, $db_type, $contentType);
    }

    /**
     * Operation dbConvertWithHttpInfo
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbType $db_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbConvert'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function dbConvertWithHttpInfo($owner, $db, $db_type, string $contentType = self::contentTypes['dbConvert'][0])
    {
        $request = $this->dbConvertRequest($owner, $db, $db_type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation dbConvertAsync
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbType $db_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbConvert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dbConvertAsync($owner, $db, $db_type, string $contentType = self::contentTypes['dbConvert'][0])
    {
        return $this->dbConvertAsyncWithHttpInfo($owner, $db, $db_type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dbConvertAsyncWithHttpInfo
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbType $db_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbConvert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dbConvertAsyncWithHttpInfo($owner, $db, $db_type, string $contentType = self::contentTypes['dbConvert'][0])
    {
        $returnType = '';
        $request = $this->dbConvertRequest($owner, $db, $db_type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dbConvert'
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbType $db_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbConvert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function dbConvertRequest($owner, $db, $db_type, string $contentType = self::contentTypes['dbConvert'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling dbConvert'
            );
        }

        // verify the required parameter 'db' is set
        if ($db === null || (is_array($db) && count($db) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db when calling dbConvert'
            );
        }

        // verify the required parameter 'db_type' is set
        if ($db_type === null || (is_array($db_type) && count($db_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db_type when calling dbConvert'
            );
        }


        $resourcePath = '/api/v1/db/{owner}/{db}/convert';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $db_type,
            'db_type', // param base name
            'DbType', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($db !== null) {
            $resourcePath = str_replace(
                '{' . 'db' . '}',
                ObjectSerializer::toPathValue($db),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dbCopy
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $new_db new_db (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbCopy'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function dbCopy($owner, $db, $new_db, string $contentType = self::contentTypes['dbCopy'][0])
    {
        $this->dbCopyWithHttpInfo($owner, $db, $new_db, $contentType);
    }

    /**
     * Operation dbCopyWithHttpInfo
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $new_db (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbCopy'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function dbCopyWithHttpInfo($owner, $db, $new_db, string $contentType = self::contentTypes['dbCopy'][0])
    {
        $request = $this->dbCopyRequest($owner, $db, $new_db, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation dbCopyAsync
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $new_db (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbCopy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dbCopyAsync($owner, $db, $new_db, string $contentType = self::contentTypes['dbCopy'][0])
    {
        return $this->dbCopyAsyncWithHttpInfo($owner, $db, $new_db, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dbCopyAsyncWithHttpInfo
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $new_db (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbCopy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dbCopyAsyncWithHttpInfo($owner, $db, $new_db, string $contentType = self::contentTypes['dbCopy'][0])
    {
        $returnType = '';
        $request = $this->dbCopyRequest($owner, $db, $new_db, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dbCopy'
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $new_db (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbCopy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function dbCopyRequest($owner, $db, $new_db, string $contentType = self::contentTypes['dbCopy'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling dbCopy'
            );
        }

        // verify the required parameter 'db' is set
        if ($db === null || (is_array($db) && count($db) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db when calling dbCopy'
            );
        }

        // verify the required parameter 'new_db' is set
        if ($new_db === null || (is_array($new_db) && count($new_db) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_db when calling dbCopy'
            );
        }


        $resourcePath = '/api/v1/db/{owner}/{db}/copy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $new_db,
            'new_db', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($db !== null) {
            $resourcePath = str_replace(
                '{' . 'db' . '}',
                ObjectSerializer::toPathValue($db),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dbDelete
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbDelete'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function dbDelete($owner, $db, string $contentType = self::contentTypes['dbDelete'][0])
    {
        $this->dbDeleteWithHttpInfo($owner, $db, $contentType);
    }

    /**
     * Operation dbDeleteWithHttpInfo
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbDelete'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function dbDeleteWithHttpInfo($owner, $db, string $contentType = self::contentTypes['dbDelete'][0])
    {
        $request = $this->dbDeleteRequest($owner, $db, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation dbDeleteAsync
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dbDeleteAsync($owner, $db, string $contentType = self::contentTypes['dbDelete'][0])
    {
        return $this->dbDeleteAsyncWithHttpInfo($owner, $db, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dbDeleteAsyncWithHttpInfo
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dbDeleteAsyncWithHttpInfo($owner, $db, string $contentType = self::contentTypes['dbDelete'][0])
    {
        $returnType = '';
        $request = $this->dbDeleteRequest($owner, $db, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dbDelete'
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function dbDeleteRequest($owner, $db, string $contentType = self::contentTypes['dbDelete'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling dbDelete'
            );
        }

        // verify the required parameter 'db' is set
        if ($db === null || (is_array($db) && count($db) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db when calling dbDelete'
            );
        }


        $resourcePath = '/api/v1/db/{owner}/{db}/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($db !== null) {
            $resourcePath = str_replace(
                '{' . 'db' . '}',
                ObjectSerializer::toPathValue($db),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dbExec
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\QueryType[] $query_type query_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbExec'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Agnesoft\AgdbApi\Model\QueryResult[]
     */
    public function dbExec($owner, $db, $query_type, string $contentType = self::contentTypes['dbExec'][0])
    {
        list($response) = $this->dbExecWithHttpInfo($owner, $db, $query_type, $contentType);
        return $response;
    }

    /**
     * Operation dbExecWithHttpInfo
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\QueryType[] $query_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbExec'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Agnesoft\AgdbApi\Model\QueryResult[], HTTP status code, HTTP response headers (array of strings)
     */
    public function dbExecWithHttpInfo($owner, $db, $query_type, string $contentType = self::contentTypes['dbExec'][0])
    {
        $request = $this->dbExecRequest($owner, $db, $query_type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Agnesoft\AgdbApi\Model\QueryResult[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Agnesoft\AgdbApi\Model\QueryResult[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agnesoft\AgdbApi\Model\QueryResult[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation dbExecAsync
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\QueryType[] $query_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbExec'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dbExecAsync($owner, $db, $query_type, string $contentType = self::contentTypes['dbExec'][0])
    {
        return $this->dbExecAsyncWithHttpInfo($owner, $db, $query_type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dbExecAsyncWithHttpInfo
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\QueryType[] $query_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbExec'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dbExecAsyncWithHttpInfo($owner, $db, $query_type, string $contentType = self::contentTypes['dbExec'][0])
    {
        $returnType = '\Agnesoft\AgdbApi\Model\QueryResult[]';
        $request = $this->dbExecRequest($owner, $db, $query_type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dbExec'
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\QueryType[] $query_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbExec'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function dbExecRequest($owner, $db, $query_type, string $contentType = self::contentTypes['dbExec'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling dbExec'
            );
        }

        // verify the required parameter 'db' is set
        if ($db === null || (is_array($db) && count($db) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db when calling dbExec'
            );
        }

        // verify the required parameter 'query_type' is set
        if ($query_type === null || (is_array($query_type) && count($query_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query_type when calling dbExec'
            );
        }


        $resourcePath = '/api/v1/db/{owner}/{db}/exec';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($db !== null) {
            $resourcePath = str_replace(
                '{' . 'db' . '}',
                ObjectSerializer::toPathValue($db),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($query_type)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($query_type));
            } else {
                $httpBody = $query_type;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dbExecMut
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\QueryType[] $query_type query_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbExecMut'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Agnesoft\AgdbApi\Model\QueryResult[]
     */
    public function dbExecMut($owner, $db, $query_type, string $contentType = self::contentTypes['dbExecMut'][0])
    {
        list($response) = $this->dbExecMutWithHttpInfo($owner, $db, $query_type, $contentType);
        return $response;
    }

    /**
     * Operation dbExecMutWithHttpInfo
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\QueryType[] $query_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbExecMut'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Agnesoft\AgdbApi\Model\QueryResult[], HTTP status code, HTTP response headers (array of strings)
     */
    public function dbExecMutWithHttpInfo($owner, $db, $query_type, string $contentType = self::contentTypes['dbExecMut'][0])
    {
        $request = $this->dbExecMutRequest($owner, $db, $query_type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Agnesoft\AgdbApi\Model\QueryResult[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Agnesoft\AgdbApi\Model\QueryResult[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agnesoft\AgdbApi\Model\QueryResult[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation dbExecMutAsync
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\QueryType[] $query_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbExecMut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dbExecMutAsync($owner, $db, $query_type, string $contentType = self::contentTypes['dbExecMut'][0])
    {
        return $this->dbExecMutAsyncWithHttpInfo($owner, $db, $query_type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dbExecMutAsyncWithHttpInfo
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\QueryType[] $query_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbExecMut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dbExecMutAsyncWithHttpInfo($owner, $db, $query_type, string $contentType = self::contentTypes['dbExecMut'][0])
    {
        $returnType = '\Agnesoft\AgdbApi\Model\QueryResult[]';
        $request = $this->dbExecMutRequest($owner, $db, $query_type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dbExecMut'
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  \Agnesoft\AgdbApi\Model\QueryType[] $query_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbExecMut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function dbExecMutRequest($owner, $db, $query_type, string $contentType = self::contentTypes['dbExecMut'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling dbExecMut'
            );
        }

        // verify the required parameter 'db' is set
        if ($db === null || (is_array($db) && count($db) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db when calling dbExecMut'
            );
        }

        // verify the required parameter 'query_type' is set
        if ($query_type === null || (is_array($query_type) && count($query_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query_type when calling dbExecMut'
            );
        }


        $resourcePath = '/api/v1/db/{owner}/{db}/exec_mut';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($db !== null) {
            $resourcePath = str_replace(
                '{' . 'db' . '}',
                ObjectSerializer::toPathValue($db),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($query_type)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($query_type));
            } else {
                $httpBody = $query_type;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dbList
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbList'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Agnesoft\AgdbApi\Model\ServerDatabase[]
     */
    public function dbList(string $contentType = self::contentTypes['dbList'][0])
    {
        list($response) = $this->dbListWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation dbListWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbList'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Agnesoft\AgdbApi\Model\ServerDatabase[], HTTP status code, HTTP response headers (array of strings)
     */
    public function dbListWithHttpInfo(string $contentType = self::contentTypes['dbList'][0])
    {
        $request = $this->dbListRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Agnesoft\AgdbApi\Model\ServerDatabase[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Agnesoft\AgdbApi\Model\ServerDatabase[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agnesoft\AgdbApi\Model\ServerDatabase[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation dbListAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dbListAsync(string $contentType = self::contentTypes['dbList'][0])
    {
        return $this->dbListAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dbListAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dbListAsyncWithHttpInfo(string $contentType = self::contentTypes['dbList'][0])
    {
        $returnType = '\Agnesoft\AgdbApi\Model\ServerDatabase[]';
        $request = $this->dbListRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dbList'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function dbListRequest(string $contentType = self::contentTypes['dbList'][0])
    {


        $resourcePath = '/api/v1/db/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dbOptimize
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbOptimize'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Agnesoft\AgdbApi\Model\ServerDatabase
     */
    public function dbOptimize($owner, $db, string $contentType = self::contentTypes['dbOptimize'][0])
    {
        list($response) = $this->dbOptimizeWithHttpInfo($owner, $db, $contentType);
        return $response;
    }

    /**
     * Operation dbOptimizeWithHttpInfo
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbOptimize'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Agnesoft\AgdbApi\Model\ServerDatabase, HTTP status code, HTTP response headers (array of strings)
     */
    public function dbOptimizeWithHttpInfo($owner, $db, string $contentType = self::contentTypes['dbOptimize'][0])
    {
        $request = $this->dbOptimizeRequest($owner, $db, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Agnesoft\AgdbApi\Model\ServerDatabase',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Agnesoft\AgdbApi\Model\ServerDatabase',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agnesoft\AgdbApi\Model\ServerDatabase',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation dbOptimizeAsync
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbOptimize'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dbOptimizeAsync($owner, $db, string $contentType = self::contentTypes['dbOptimize'][0])
    {
        return $this->dbOptimizeAsyncWithHttpInfo($owner, $db, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dbOptimizeAsyncWithHttpInfo
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbOptimize'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dbOptimizeAsyncWithHttpInfo($owner, $db, string $contentType = self::contentTypes['dbOptimize'][0])
    {
        $returnType = '\Agnesoft\AgdbApi\Model\ServerDatabase';
        $request = $this->dbOptimizeRequest($owner, $db, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dbOptimize'
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbOptimize'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function dbOptimizeRequest($owner, $db, string $contentType = self::contentTypes['dbOptimize'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling dbOptimize'
            );
        }

        // verify the required parameter 'db' is set
        if ($db === null || (is_array($db) && count($db) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db when calling dbOptimize'
            );
        }


        $resourcePath = '/api/v1/db/{owner}/{db}/optimize';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($db !== null) {
            $resourcePath = str_replace(
                '{' . 'db' . '}',
                ObjectSerializer::toPathValue($db),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dbRemove
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbRemove'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function dbRemove($owner, $db, string $contentType = self::contentTypes['dbRemove'][0])
    {
        $this->dbRemoveWithHttpInfo($owner, $db, $contentType);
    }

    /**
     * Operation dbRemoveWithHttpInfo
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbRemove'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function dbRemoveWithHttpInfo($owner, $db, string $contentType = self::contentTypes['dbRemove'][0])
    {
        $request = $this->dbRemoveRequest($owner, $db, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation dbRemoveAsync
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbRemove'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dbRemoveAsync($owner, $db, string $contentType = self::contentTypes['dbRemove'][0])
    {
        return $this->dbRemoveAsyncWithHttpInfo($owner, $db, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dbRemoveAsyncWithHttpInfo
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbRemove'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dbRemoveAsyncWithHttpInfo($owner, $db, string $contentType = self::contentTypes['dbRemove'][0])
    {
        $returnType = '';
        $request = $this->dbRemoveRequest($owner, $db, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dbRemove'
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbRemove'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function dbRemoveRequest($owner, $db, string $contentType = self::contentTypes['dbRemove'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling dbRemove'
            );
        }

        // verify the required parameter 'db' is set
        if ($db === null || (is_array($db) && count($db) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db when calling dbRemove'
            );
        }


        $resourcePath = '/api/v1/db/{owner}/{db}/remove';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($db !== null) {
            $resourcePath = str_replace(
                '{' . 'db' . '}',
                ObjectSerializer::toPathValue($db),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dbRename
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $new_db new_db (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbRename'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function dbRename($owner, $db, $new_db, string $contentType = self::contentTypes['dbRename'][0])
    {
        $this->dbRenameWithHttpInfo($owner, $db, $new_db, $contentType);
    }

    /**
     * Operation dbRenameWithHttpInfo
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $new_db (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbRename'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function dbRenameWithHttpInfo($owner, $db, $new_db, string $contentType = self::contentTypes['dbRename'][0])
    {
        $request = $this->dbRenameRequest($owner, $db, $new_db, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation dbRenameAsync
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $new_db (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbRename'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dbRenameAsync($owner, $db, $new_db, string $contentType = self::contentTypes['dbRename'][0])
    {
        return $this->dbRenameAsyncWithHttpInfo($owner, $db, $new_db, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dbRenameAsyncWithHttpInfo
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $new_db (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbRename'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dbRenameAsyncWithHttpInfo($owner, $db, $new_db, string $contentType = self::contentTypes['dbRename'][0])
    {
        $returnType = '';
        $request = $this->dbRenameRequest($owner, $db, $new_db, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dbRename'
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $new_db (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbRename'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function dbRenameRequest($owner, $db, $new_db, string $contentType = self::contentTypes['dbRename'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling dbRename'
            );
        }

        // verify the required parameter 'db' is set
        if ($db === null || (is_array($db) && count($db) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db when calling dbRename'
            );
        }

        // verify the required parameter 'new_db' is set
        if ($new_db === null || (is_array($new_db) && count($new_db) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_db when calling dbRename'
            );
        }


        $resourcePath = '/api/v1/db/{owner}/{db}/rename';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $new_db,
            'new_db', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($db !== null) {
            $resourcePath = str_replace(
                '{' . 'db' . '}',
                ObjectSerializer::toPathValue($db),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dbRestore
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbRestore'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function dbRestore($owner, $db, string $contentType = self::contentTypes['dbRestore'][0])
    {
        $this->dbRestoreWithHttpInfo($owner, $db, $contentType);
    }

    /**
     * Operation dbRestoreWithHttpInfo
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbRestore'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function dbRestoreWithHttpInfo($owner, $db, string $contentType = self::contentTypes['dbRestore'][0])
    {
        $request = $this->dbRestoreRequest($owner, $db, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation dbRestoreAsync
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbRestore'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dbRestoreAsync($owner, $db, string $contentType = self::contentTypes['dbRestore'][0])
    {
        return $this->dbRestoreAsyncWithHttpInfo($owner, $db, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dbRestoreAsyncWithHttpInfo
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbRestore'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dbRestoreAsyncWithHttpInfo($owner, $db, string $contentType = self::contentTypes['dbRestore'][0])
    {
        $returnType = '';
        $request = $this->dbRestoreRequest($owner, $db, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dbRestore'
     *
     * @param  string $owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbRestore'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function dbRestoreRequest($owner, $db, string $contentType = self::contentTypes['dbRestore'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling dbRestore'
            );
        }

        // verify the required parameter 'db' is set
        if ($db === null || (is_array($db) && count($db) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db when calling dbRestore'
            );
        }


        $resourcePath = '/api/v1/db/{owner}/{db}/restore';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($db !== null) {
            $resourcePath = str_replace(
                '{' . 'db' . '}',
                ObjectSerializer::toPathValue($db),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dbUserAdd
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $username user name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbUserRole $db_role db_role (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbUserAdd'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function dbUserAdd($owner, $db, $username, $db_role, string $contentType = self::contentTypes['dbUserAdd'][0])
    {
        $this->dbUserAddWithHttpInfo($owner, $db, $username, $db_role, $contentType);
    }

    /**
     * Operation dbUserAddWithHttpInfo
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $username user name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbUserRole $db_role (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbUserAdd'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function dbUserAddWithHttpInfo($owner, $db, $username, $db_role, string $contentType = self::contentTypes['dbUserAdd'][0])
    {
        $request = $this->dbUserAddRequest($owner, $db, $username, $db_role, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation dbUserAddAsync
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $username user name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbUserRole $db_role (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbUserAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dbUserAddAsync($owner, $db, $username, $db_role, string $contentType = self::contentTypes['dbUserAdd'][0])
    {
        return $this->dbUserAddAsyncWithHttpInfo($owner, $db, $username, $db_role, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dbUserAddAsyncWithHttpInfo
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $username user name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbUserRole $db_role (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbUserAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dbUserAddAsyncWithHttpInfo($owner, $db, $username, $db_role, string $contentType = self::contentTypes['dbUserAdd'][0])
    {
        $returnType = '';
        $request = $this->dbUserAddRequest($owner, $db, $username, $db_role, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dbUserAdd'
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $username user name (required)
     * @param  \Agnesoft\AgdbApi\Model\DbUserRole $db_role (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbUserAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function dbUserAddRequest($owner, $db, $username, $db_role, string $contentType = self::contentTypes['dbUserAdd'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling dbUserAdd'
            );
        }

        // verify the required parameter 'db' is set
        if ($db === null || (is_array($db) && count($db) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db when calling dbUserAdd'
            );
        }

        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling dbUserAdd'
            );
        }

        // verify the required parameter 'db_role' is set
        if ($db_role === null || (is_array($db_role) && count($db_role) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db_role when calling dbUserAdd'
            );
        }


        $resourcePath = '/api/v1/db/{owner}/{db}/user/{username}/add';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $db_role,
            'db_role', // param base name
            'DbUserRole', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($db !== null) {
            $resourcePath = str_replace(
                '{' . 'db' . '}',
                ObjectSerializer::toPathValue($db),
                $resourcePath
            );
        }
        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dbUserList
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbUserList'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Agnesoft\AgdbApi\Model\DbUser[]
     */
    public function dbUserList($owner, $db, string $contentType = self::contentTypes['dbUserList'][0])
    {
        list($response) = $this->dbUserListWithHttpInfo($owner, $db, $contentType);
        return $response;
    }

    /**
     * Operation dbUserListWithHttpInfo
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbUserList'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Agnesoft\AgdbApi\Model\DbUser[], HTTP status code, HTTP response headers (array of strings)
     */
    public function dbUserListWithHttpInfo($owner, $db, string $contentType = self::contentTypes['dbUserList'][0])
    {
        $request = $this->dbUserListRequest($owner, $db, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Agnesoft\AgdbApi\Model\DbUser[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Agnesoft\AgdbApi\Model\DbUser[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agnesoft\AgdbApi\Model\DbUser[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation dbUserListAsync
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbUserList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dbUserListAsync($owner, $db, string $contentType = self::contentTypes['dbUserList'][0])
    {
        return $this->dbUserListAsyncWithHttpInfo($owner, $db, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dbUserListAsyncWithHttpInfo
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbUserList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dbUserListAsyncWithHttpInfo($owner, $db, string $contentType = self::contentTypes['dbUserList'][0])
    {
        $returnType = '\Agnesoft\AgdbApi\Model\DbUser[]';
        $request = $this->dbUserListRequest($owner, $db, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dbUserList'
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbUserList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function dbUserListRequest($owner, $db, string $contentType = self::contentTypes['dbUserList'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling dbUserList'
            );
        }

        // verify the required parameter 'db' is set
        if ($db === null || (is_array($db) && count($db) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db when calling dbUserList'
            );
        }


        $resourcePath = '/api/v1/db/{owner}/{db}/user/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($db !== null) {
            $resourcePath = str_replace(
                '{' . 'db' . '}',
                ObjectSerializer::toPathValue($db),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dbUserRemove
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $username user name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbUserRemove'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function dbUserRemove($owner, $db, $username, string $contentType = self::contentTypes['dbUserRemove'][0])
    {
        $this->dbUserRemoveWithHttpInfo($owner, $db, $username, $contentType);
    }

    /**
     * Operation dbUserRemoveWithHttpInfo
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $username user name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbUserRemove'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function dbUserRemoveWithHttpInfo($owner, $db, $username, string $contentType = self::contentTypes['dbUserRemove'][0])
    {
        $request = $this->dbUserRemoveRequest($owner, $db, $username, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation dbUserRemoveAsync
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $username user name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbUserRemove'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dbUserRemoveAsync($owner, $db, $username, string $contentType = self::contentTypes['dbUserRemove'][0])
    {
        return $this->dbUserRemoveAsyncWithHttpInfo($owner, $db, $username, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dbUserRemoveAsyncWithHttpInfo
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $username user name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbUserRemove'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dbUserRemoveAsyncWithHttpInfo($owner, $db, $username, string $contentType = self::contentTypes['dbUserRemove'][0])
    {
        $returnType = '';
        $request = $this->dbUserRemoveRequest($owner, $db, $username, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dbUserRemove'
     *
     * @param  string $owner db owner user name (required)
     * @param  string $db db name (required)
     * @param  string $username user name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dbUserRemove'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function dbUserRemoveRequest($owner, $db, $username, string $contentType = self::contentTypes['dbUserRemove'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling dbUserRemove'
            );
        }

        // verify the required parameter 'db' is set
        if ($db === null || (is_array($db) && count($db) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db when calling dbUserRemove'
            );
        }

        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling dbUserRemove'
            );
        }


        $resourcePath = '/api/v1/db/{owner}/{db}/user/{username}/remove';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($db !== null) {
            $resourcePath = str_replace(
                '{' . 'db' . '}',
                ObjectSerializer::toPathValue($db),
                $resourcePath
            );
        }
        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation status
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['status'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function status(string $contentType = self::contentTypes['status'][0])
    {
        $this->statusWithHttpInfo($contentType);
    }

    /**
     * Operation statusWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['status'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function statusWithHttpInfo(string $contentType = self::contentTypes['status'][0])
    {
        $request = $this->statusRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation statusAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['status'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function statusAsync(string $contentType = self::contentTypes['status'][0])
    {
        return $this->statusAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation statusAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['status'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function statusAsyncWithHttpInfo(string $contentType = self::contentTypes['status'][0])
    {
        $returnType = '';
        $request = $this->statusRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'status'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['status'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function statusRequest(string $contentType = self::contentTypes['status'][0])
    {


        $resourcePath = '/api/v1/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userChangePassword
     *
     * @param  \Agnesoft\AgdbApi\Model\ChangePassword $change_password change_password (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userChangePassword'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function userChangePassword($change_password, string $contentType = self::contentTypes['userChangePassword'][0])
    {
        $this->userChangePasswordWithHttpInfo($change_password, $contentType);
    }

    /**
     * Operation userChangePasswordWithHttpInfo
     *
     * @param  \Agnesoft\AgdbApi\Model\ChangePassword $change_password (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userChangePassword'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function userChangePasswordWithHttpInfo($change_password, string $contentType = self::contentTypes['userChangePassword'][0])
    {
        $request = $this->userChangePasswordRequest($change_password, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation userChangePasswordAsync
     *
     * @param  \Agnesoft\AgdbApi\Model\ChangePassword $change_password (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userChangePassword'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function userChangePasswordAsync($change_password, string $contentType = self::contentTypes['userChangePassword'][0])
    {
        return $this->userChangePasswordAsyncWithHttpInfo($change_password, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation userChangePasswordAsyncWithHttpInfo
     *
     * @param  \Agnesoft\AgdbApi\Model\ChangePassword $change_password (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userChangePassword'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function userChangePasswordAsyncWithHttpInfo($change_password, string $contentType = self::contentTypes['userChangePassword'][0])
    {
        $returnType = '';
        $request = $this->userChangePasswordRequest($change_password, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'userChangePassword'
     *
     * @param  \Agnesoft\AgdbApi\Model\ChangePassword $change_password (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userChangePassword'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function userChangePasswordRequest($change_password, string $contentType = self::contentTypes['userChangePassword'][0])
    {

        // verify the required parameter 'change_password' is set
        if ($change_password === null || (is_array($change_password) && count($change_password) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $change_password when calling userChangePassword'
            );
        }


        $resourcePath = '/api/v1/user/change_password';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($change_password)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($change_password));
            } else {
                $httpBody = $change_password;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userLogin
     *
     * @param  \Agnesoft\AgdbApi\Model\UserLogin $user_login user_login (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userLogin'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return string
     */
    public function userLogin($user_login, string $contentType = self::contentTypes['userLogin'][0])
    {
        list($response) = $this->userLoginWithHttpInfo($user_login, $contentType);
        return $response;
    }

    /**
     * Operation userLoginWithHttpInfo
     *
     * @param  \Agnesoft\AgdbApi\Model\UserLogin $user_login (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userLogin'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function userLoginWithHttpInfo($user_login, string $contentType = self::contentTypes['userLogin'][0])
    {
        $request = $this->userLoginRequest($user_login, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'string',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'string',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation userLoginAsync
     *
     * @param  \Agnesoft\AgdbApi\Model\UserLogin $user_login (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userLogin'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function userLoginAsync($user_login, string $contentType = self::contentTypes['userLogin'][0])
    {
        return $this->userLoginAsyncWithHttpInfo($user_login, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation userLoginAsyncWithHttpInfo
     *
     * @param  \Agnesoft\AgdbApi\Model\UserLogin $user_login (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userLogin'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function userLoginAsyncWithHttpInfo($user_login, string $contentType = self::contentTypes['userLogin'][0])
    {
        $returnType = 'string';
        $request = $this->userLoginRequest($user_login, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'userLogin'
     *
     * @param  \Agnesoft\AgdbApi\Model\UserLogin $user_login (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userLogin'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function userLoginRequest($user_login, string $contentType = self::contentTypes['userLogin'][0])
    {

        // verify the required parameter 'user_login' is set
        if ($user_login === null || (is_array($user_login) && count($user_login) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_login when calling userLogin'
            );
        }


        $resourcePath = '/api/v1/user/login';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($user_login)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($user_login));
            } else {
                $httpBody = $user_login;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userLogout
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userLogout'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function userLogout(string $contentType = self::contentTypes['userLogout'][0])
    {
        $this->userLogoutWithHttpInfo($contentType);
    }

    /**
     * Operation userLogoutWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userLogout'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function userLogoutWithHttpInfo(string $contentType = self::contentTypes['userLogout'][0])
    {
        $request = $this->userLogoutRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation userLogoutAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userLogout'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function userLogoutAsync(string $contentType = self::contentTypes['userLogout'][0])
    {
        return $this->userLogoutAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation userLogoutAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userLogout'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function userLogoutAsyncWithHttpInfo(string $contentType = self::contentTypes['userLogout'][0])
    {
        $returnType = '';
        $request = $this->userLogoutRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'userLogout'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userLogout'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function userLogoutRequest(string $contentType = self::contentTypes['userLogout'][0])
    {


        $resourcePath = '/api/v1/user/logout';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userStatus
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userStatus'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Agnesoft\AgdbApi\Model\UserStatus
     */
    public function userStatus(string $contentType = self::contentTypes['userStatus'][0])
    {
        list($response) = $this->userStatusWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation userStatusWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userStatus'] to see the possible values for this operation
     *
     * @throws \Agnesoft\AgdbApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Agnesoft\AgdbApi\Model\UserStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function userStatusWithHttpInfo(string $contentType = self::contentTypes['userStatus'][0])
    {
        $request = $this->userStatusRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Agnesoft\AgdbApi\Model\UserStatus',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Agnesoft\AgdbApi\Model\UserStatus',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agnesoft\AgdbApi\Model\UserStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation userStatusAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function userStatusAsync(string $contentType = self::contentTypes['userStatus'][0])
    {
        return $this->userStatusAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation userStatusAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function userStatusAsyncWithHttpInfo(string $contentType = self::contentTypes['userStatus'][0])
    {
        $returnType = '\Agnesoft\AgdbApi\Model\UserStatus';
        $request = $this->userStatusRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'userStatus'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function userStatusRequest(string $contentType = self::contentTypes['userStatus'][0])
    {


        $resourcePath = '/api/v1/user/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
